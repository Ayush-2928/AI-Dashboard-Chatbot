<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    
    <style>
        body { 
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #e2e8f0; 
            font-family: 'Outfit', system-ui, -apple-system, sans-serif; 
            margin: 0; padding: 0;
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
        }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            grid-template-rows: auto auto auto;
            grid-auto-rows: minmax(168px, auto);
            gap: 16px;
            min-height: 100vh;
            height: auto;
            padding: 20px 20px 20px 20px;
            box-sizing: border-box;
            overflow: visible;
            overflow-x: hidden;
            align-content: start;
        }

        .dashboard-grid.with-chatbot-dock {
            padding-bottom: 180px;
        }

        .full-span { grid-column: 1 / -1 !important; }

        .dashboard-grid > * {
            min-width: 0;
            min-height: 0;
        }
        
        #chart_0 { grid-column: span 1; }
        #chart_1 { grid-column: span 1; }
        #chart_2 { grid-column: span 1; }
        #chart_3 { grid-column: span 1; }
        #chart_4 { grid-column: span 1; }

        .glass-panel {
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: visible;
            padding: 8px;
            z-index: 1;
            min-width: 260px;
            min-height: 120px;
            resize: none;
        }

        .glass-panel:hover {
            z-index: 35;
        }

        .glass-panel:hover .expand-btn {
            opacity: 1;
        }

        .glass-panel.chart-empty-slot {
            background: transparent !important;
            backdrop-filter: none !important;
            border-color: transparent !important;
            box-shadow: none !important;
            padding: 0 !important;
        }

        .expand-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 10;
            background: rgba(59, 130, 246, 0.8);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 13px;
            opacity: 0;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .expand-btn:hover {
            background: rgba(59, 130, 246, 1);
            transform: scale(1.05);
        }

.widget-drag-handle {
    position: absolute;
    top: 10px;
    right: 80px;
    z-index: 14;
    background: rgba(30, 41, 59, 0.92);
    color: #cbd5e1;
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 8px;
    padding: 4px 8px;
    font-size: 10px;
    line-height: 1;
    cursor: grab;
    user-select: none;
}

.widget-drag-handle:active {
    cursor: grabbing;
}

.widget-remove-btn {
    position: absolute;
    right: 8px;
    top: 8px;
    z-index: 15;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 1px solid rgba(148, 163, 184, 0.18);
    background: rgba(15, 23, 42, 0.2);
    color: rgba(203, 213, 225, 0.8);
    font-size: 10px;
    line-height: 14px;
    text-align: center;
    cursor: pointer;
    padding: 0;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.18s ease, background 0.18s ease, border-color 0.18s ease, color 0.18s ease;
}

.glass-panel:hover .widget-remove-btn,
.kpi-card:hover .widget-remove-btn {
    opacity: 1;
    pointer-events: auto;
}

.widget-remove-btn:hover {
    background: rgba(127, 29, 29, 0.42);
    border-color: rgba(239, 68, 68, 0.45);
    color: #fee2e2;
}

.chart-plot-area {
    width: 100%;
    height: 100%;
}


        .chart-controls {
    position: absolute;
    top: 12px;
    left: 12px;
    z-index: 10;
    display: flex;
    gap: 6px;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.glass-panel:hover .chart-controls {
    opacity: 1;
}

.control-btn {
    background: rgba(30, 41, 59, 0.9);
    color: #94a3b8;
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 6px;
    padding: 6px 8px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
    backdrop-filter: blur(10px);
}

.control-btn:hover {
    background: rgba(59, 130, 246, 0.8);
    color: white;
    border-color: #8b5cf6;
    transform: scale(1.1);
}

.chart-controls.open {
    opacity: 1;
}

.edit-menu {
    position: relative;
}

.edit-toggle,
.reset-toggle {
    font-size: 13px;
    min-width: 58px;
    height: 30px;
    padding: 0 10px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.edit-dropdown {
    position: absolute;
    top: 34px;
    left: 0;
    width: 240px;
    max-height: min(220px, calc(100vh - 140px));
    overflow-y: auto;
    background: rgba(15, 23, 42, 0.98);
    border: 1px solid rgba(148, 163, 184, 0.25);
    border-radius: 12px;
    box-shadow: 0 12px 28px rgba(0, 0, 0, 0.45);
    padding: 8px;
    display: none;
    z-index: 60;
}

.edit-dropdown.open {
    display: block;
}

.edit-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.edit-label {
    width: 68px;
    font-size: 10px;
    color: #94a3b8;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.edit-select {
    flex: 1;
    background: rgba(30, 41, 59, 1);
    border: 1px solid rgba(100, 116, 139, 0.6);
    border-radius: 6px;
    color: #e2e8f0;
    font-size: 13px;
    padding: 5px 6px;
}

.edit-item {
    width: 100%;
    text-align: left;
    background: transparent;
    border: 1px solid transparent;
    color: #cbd5e1;
    border-radius: 6px;
    font-size: 12px;
    padding: 6px 8px;
    cursor: pointer;
    transition: all 0.15s ease;
    margin-bottom: 4px;
}

.edit-item:last-child {
    margin-bottom: 0;
}

.edit-item:hover {
    background: rgba(51, 65, 85, 0.75);
    border-color: rgba(148, 163, 184, 0.25);
    color: #ffffff;
}

        
        .kpi-card {
            background: linear-gradient(145deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.7));
            border-left: 4px solid;
            border-radius: 12px;
            padding: 12px 16px;
            display: grid;
            grid-template-columns: 1fr 120px;
            gap: 12px;
            align-items: center;
            transition: box-shadow 0.3s ease;
            position: relative;
            overflow: visible;
            min-height: 92px;
            min-width: 220px;
            resize: none;
            cursor: default;
        }
        
        .kpi-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
        }
        
        .kpi-card:hover { 
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
        }

        .sparkline-container {
            height: 60px;
            position: relative;
            width: 120px;
            flex-shrink: 0;
        }

        .trend-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 800;
            line-height: 1.15;
            margin-top: 6px;
            max-width: fit-content;
            white-space: nowrap;
        }

        .trend-up {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .trend-down {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .kpi-card.kpi-replace-target {
            border-color: #8b5cf6;
            box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.25), 0 10px 22px rgba(2, 132, 199, 0.18);
        }

        .kpi-card.kpi-drop-target {
            border-color: #8b5cf6;
            box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.52), 0 12px 28px rgba(2, 132, 199, 0.32);
        }
        .filter-scroll {
            overflow: visible;
            white-space: normal;
            scrollbar-width: thin;
            scrollbar-color: #475569 #1e293b;
        }

        .filter-scroll::-webkit-scrollbar {
            height: 6px;
        }

        .filter-scroll::-webkit-scrollbar-track {
            background: #1e293b;
            border-radius: 12px;
        }

        .filter-scroll::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 12px;
        }

        .loader {
            border: 3px solid rgba(255,255,255,0.1); 
            border-top: 3px solid #8b5cf6; 
            border-radius: 50%; 
            width: 24px; 
            height: 24px; 
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }

        .filter-loading-overlay {
            position: fixed;
            inset: 0;
            z-index: 1400;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(2, 6, 23, 0.58);
            backdrop-filter: blur(3px);
        }

        .filter-loading-overlay.active {
            display: flex;
        }

        .filter-loading-card {
            width: min(540px, calc(100vw - 32px));
            background: rgba(17, 24, 39, 0.96);
            border: 1px solid rgba(148, 163, 184, 0.24);
            border-radius: 14px;
            padding: 14px;
            box-shadow: 0 22px 48px rgba(0, 0, 0, 0.48);
        }

        .filter-loading-title {
            font-size: 14px;
            font-weight: 700;
            color: #e5e7eb;
            margin-bottom: 10px;
        }

        .filter-loading-track {
            width: 100%;
            height: 10px;
            border-radius: 999px;
            overflow: hidden;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(148, 163, 184, 0.22);
            margin-bottom: 10px;
        }

        .filter-loading-bar {
            height: 100%;
            width: 45%;
            border-radius: inherit;
            background: linear-gradient(90deg, #22c55e, #8b5cf6);
            animation: filterLoadSlide 1.25s ease-in-out infinite;
        }

        @keyframes filterLoadSlide {
            0% { transform: translateX(-110%); }
            100% { transform: translateX(220%); }
        }

        .filter-loading-actions {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }

        .filter-loading-note {
            color: #94a3b8;
            font-size: 13px;
        }

        .filter-loading-stop {
            border: 1px solid rgba(248, 113, 113, 0.45);
            background: rgba(127, 29, 29, 0.28);
            color: #fecaca;
            border-radius: 8px;
            font-size: 13px;
            padding: 7px 10px;
            cursor: pointer;
        }

        .filter-loading-stop:disabled {
            opacity: 0.65;
            cursor: not-allowed;
        }

        body.filter-loading-active #dashboard-screen,
        body.filter-loading-active #chart-sidebar,
        body.filter-loading-active #chart-chatbot-dock,
        body.filter-loading-active #custom-chart-popup,
        body.filter-loading-active #custom-kpi-popup,
        body.filter-loading-active #chart-modal,
        body.filter-loading-active #logs-modal {
            pointer-events: none !important;
            user-select: none;
        }

        body.filter-loading-active #dashboard-screen {
            filter: saturate(0.8) brightness(0.92);
        }

        .upload-zone {
            transition: all 0.3s ease;
        }

        .upload-zone:hover {
            transform: scale(1.02);
            border-color: #8b5cf6 !important;
        }

        .pulse-dot {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Modal Styles - FIXED FOR FULL CHART DISPLAY */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: linear-gradient(145deg, rgba(30, 41, 59, 0.98), rgba(15, 23, 42, 0.98));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            width: 90vw;
            height: 88vh;
            max-width: 1600px;
            max-height: 900px;
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            padding: 20px 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .modal-body {
            flex: 1;
            padding: 30px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .modal-body > div {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .close-btn {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid #ef4444;
            border-radius: 12px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: rgba(239, 68, 68, 0.4);
            transform: scale(1.05);
        }

        .date-input-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 8px 12px;
            transition: all 0.2s ease;
        }

        .date-input-wrapper:hover {
            border-color: #8b5cf6;
            background: rgba(30, 41, 59, 0.7);
        }

        .date-input-wrapper input[type="date"] {
            background: transparent;
            border: none;
            color: #e2e8f0;
            font-size: 12px;
            cursor: pointer;
        }

        .date-input-wrapper input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(1);
            cursor: pointer;
        }

.glass-panel.drop-target {
    border-color: #8b5cf6;
    box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.45), 0 14px 30px rgba(2, 132, 199, 0.28);
}

.chatbot-dock {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: 16px;
    width: min(1100px, calc(100vw - 28px));
    background: rgba(15, 23, 42, 0.9);
    border: 1px solid rgba(148, 163, 184, 0.22);
    border-radius: 14px;
    backdrop-filter: blur(12px);
    padding: 10px;
    z-index: 1200;
    display: flex;
    align-items: center;
    gap: 10px;
}

.chatbot-mode {
    background: rgba(30, 41, 59, 0.85);
    border: 1px solid rgba(148, 163, 184, 0.3);
    border-radius: 12px;
    padding: 10px 10px;
    color: #e2e8f0;
    font-size: 12px;
}

.chatbot-mode:focus {
    outline: none;
    border-color: #8b5cf6;
}

.chatbot-input {
    flex: 1;
    background: rgba(30, 41, 59, 0.85);
    border: 1px solid rgba(148, 163, 184, 0.3);
    border-radius: 12px;
    padding: 10px 12px;
    color: #e2e8f0;
    font-size: 13px;
}

.chatbot-input:focus {
    outline: none;
    border-color: #8b5cf6;
}

.chatbot-button {
    background: linear-gradient(90deg, #8b5cf6, #7c3aed);
    border: none;
    color: white;
    border-radius: 12px;
    padding: 10px 14px;
    font-size: 12px;
    font-weight: 700;
    cursor: pointer;
    white-space: nowrap;
}

.chatbot-button:disabled {
    opacity: 0.65;
    cursor: not-allowed;
}

.chatbot-status {
    color: #c4b5fd;
    font-size: 13px;
    min-width: 170px;
    text-align: right;
}

.chatbot-close-btn {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: 1px solid rgba(148, 163, 184, 0.18);
    background: rgba(15, 23, 42, 0.2);
    color: rgba(203, 213, 225, 0.8);
    font-size: 10px;
    line-height: 14px;
    text-align: center;
    cursor: pointer;
    padding: 0;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.18s ease, background 0.18s ease, border-color 0.18s ease, color 0.18s ease;
}

.chatbot-dock:hover .chatbot-close-btn {
    opacity: 1;
    pointer-events: auto;
}

.chatbot-close-btn:hover {
    background: rgba(127, 29, 29, 0.42);
    border-color: rgba(239, 68, 68, 0.45);
    color: #fee2e2;
}

.custom-chart-popup {
    position: fixed;
    width: min(620px, calc(100vw - 30px));
    height: min(460px, calc(100vh - 50px));
    background: linear-gradient(150deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 59, 0.98));
    border: 1px solid rgba(148, 163, 184, 0.26);
    border-radius: 14px;
    box-shadow: 0 20px 48px rgba(2, 6, 23, 0.6);
    z-index: 1300;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.custom-chart-popup.dragging {
    opacity: 0.92;
}

.custom-chart-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 12px;
    border-bottom: 1px solid rgba(148, 163, 184, 0.22);
    cursor: move;
    user-select: none;
}

.custom-chart-title {
    font-size: 13px;
    font-weight: 700;
    color: #f8fafc;
}

.popup-header-actions {
    display: inline-flex;
    align-items: center;
    gap: 6px;
}

.popup-action-btn {
    padding: 6px 10px;
    font-size: 13px;
}

.custom-replace-row {
    display: flex;
    align-items: center;
    gap: 8px;
}

.custom-replace-select {
    flex: 1;
    min-width: 0;
    background: rgba(30, 41, 59, 0.85);
    border: 1px solid rgba(148, 163, 184, 0.3);
    border-radius: 8px;
    padding: 7px 9px;
    color: #e2e8f0;
    font-size: 13px;
}

.custom-chart-body {
    flex: 1;
    min-height: 0;
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.custom-chart-plot {
    flex: 1;
    min-height: 0;
}

.custom-chart-note {
    color: #94a3b8;
    font-size: 13px;
}

.custom-chart-sql {
    color: #c4b5fd;
    font-size: 10px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    padding: 6px 8px;
    border-radius: 8px;
    background: rgba(15, 23, 42, 0.7);
    border: 1px solid rgba(148, 163, 184, 0.18);
}

.custom-chart-sql-row {
    display: flex;
    gap: 8px;
    align-items: center;
}


.custom-kpi-popup {
    position: fixed;
    width: min(340px, calc(100vw - 20px));
    background: linear-gradient(150deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 59, 0.98));
    border: 1px solid rgba(148, 163, 184, 0.28);
    border-radius: 14px;
    box-shadow: 0 20px 44px rgba(2, 6, 23, 0.62);
    z-index: 1310;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.custom-kpi-popup.dragging {
    opacity: 0.92;
}

.custom-kpi-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 10px 12px;
    border-bottom: 1px solid rgba(148, 163, 184, 0.24);
    cursor: move;
    user-select: none;
}

.custom-kpi-body {
    padding: 10px;
}

.copy-sql-btn {
    padding: 10px 14px;
    font-size: 13px;
}


.dashboard-grid.with-sidebar {
    width: calc(100vw - 340px);
    margin-right: 340px;
}

.chart-sidebar {
    position: fixed;
    top: 16px;
    right: 16px;
    bottom: 86px;
    width: 310px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    background: rgba(15, 23, 42, 0.92);
    border: 1px solid rgba(148, 163, 184, 0.24);
    border-radius: 16px;
    backdrop-filter: blur(10px);
    box-shadow: 0 20px 44px rgba(2, 6, 23, 0.5);
    z-index: 1180;
    padding: 12px;
}

.chart-sidebar-header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 8px;
}

.chart-sidebar-title {
    font-size: 14px;
    font-weight: 700;
    color: #e2e8f0;
}

.chart-sidebar-subtitle {
    font-size: 13px;
    color: #94a3b8;
}

.chart-sidebar-clear {
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 8px;
    background: rgba(30, 41, 59, 0.8);
    color: #cbd5e1;
    font-size: 13px;
    padding: 6px 8px;
    cursor: pointer;
}

.chart-sidebar-clear:hover {
    border-color: #8b5cf6;
    color: #f8fafc;
}

.chart-sidebar-header-actions {
    display: flex;
    align-items: center;
    gap: 6px;
}

.chart-sidebar-close {
    width: 28px;
    height: 28px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 8px;
    background: rgba(30, 41, 59, 0.8);
    color: #cbd5e1;
    font-size: 13px;
    line-height: 1;
    cursor: pointer;
}

.chart-sidebar-close:hover {
    border-color: #f87171;
    color: #fee2e2;
    background: rgba(127, 29, 29, 0.3);
}

.chart-library-list {
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 8px;
    min-height: 0;
    padding-right: 2px;
}

.chart-library-item {
    background: rgba(30, 41, 59, 0.7);
    border: 1px solid rgba(148, 163, 184, 0.2);
    border-radius: 12px;
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.chart-library-item.active {
    border-color: rgba(56, 189, 248, 0.8);
    box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.45);
}

.chart-library-title {
    color: #e2e8f0;
    font-size: 12px;
    font-weight: 700;
    line-height: 1.25;
    word-break: break-word;
}

.chart-library-meta {
    color: #94a3b8;
    font-size: 10px;
}

.chart-library-actions {
    display: flex;
    gap: 6px;
}

.chart-library-btn {
    flex: 1;
    border: 1px solid rgba(148, 163, 184, 0.28);
    border-radius: 7px;
    background: rgba(15, 23, 42, 0.75);
    color: #cbd5e1;
    font-size: 10px;
    padding: 6px 6px;
    cursor: pointer;
}

.chart-library-btn:hover {
    border-color: #8b5cf6;
    color: #ffffff;
}

.chart-library-empty {
    color: #64748b;
    font-size: 13px;
    border: 1px dashed rgba(148, 163, 184, 0.25);
    border-radius: 12px;
    padding: 12px;
    text-align: center;
}

@media (max-width: 1250px) {
    .dashboard-grid.with-sidebar {
        width: 100vw;
        margin-right: 0;
    }
    .chart-sidebar {
        width: 260px;
        right: 10px;
    }
}

@media (max-width: 900px) {
    .dashboard-grid.with-chatbot-dock {
        padding-bottom: 150px;
    }
    .chatbot-dock {
        width: calc(100vw - 16px);
        left: 8px;
        transform: none;
        flex-wrap: wrap;
    }
    .chatbot-status {
        text-align: left;
        min-width: auto;
    }
}


        :root {
            --app-bg: #101114;
            --app-bg-soft: #17191f;
            --app-bg-soft-2: #13151a;
            --app-border: rgba(255, 255, 255, 0.07);
            --app-text: #e4e4e7;
            --app-muted: #8b8f98;
            --app-accent: #22c55e;
            --app-accent-strong: #16a34a;
        }

        body {
            background: var(--app-bg) !important;
            color: var(--app-text) !important;
            font-family: 'Outfit', system-ui, -apple-system, sans-serif !important;
        }

        .dashboard-grid {
            background: var(--app-bg);
        }

        .glass-panel {
            background: rgba(26, 27, 31, 0.92);
            border: 1px solid var(--app-border);
            box-shadow: 0 8px 28px rgba(0, 0, 0, 0.48);
        }

        .kpi-card {
            background: linear-gradient(145deg, rgba(26, 27, 31, 0.96), rgba(17, 18, 21, 0.94));
            border-left-color: var(--app-accent) !important;
        }

        .startup-card {
            background: var(--app-bg-soft) !important;
            border-color: var(--app-border) !important;
            box-shadow: 0 20px 48px rgba(0, 0, 0, 0.55);
        }

        .startup-title {
            color: #ffffff;
            letter-spacing: -0.02em;
        }

        .startup-subtitle,
        .loader-caption {
            color: var(--app-muted) !important;
        }

        .primary-cta {
            background: var(--app-accent) !important;
            color: #ffffff;
        }

        .primary-cta:hover {
            background: var(--app-accent-strong) !important;
        }

        .secondary-cta {
            background: rgba(255, 255, 255, 0.03) !important;
            border: 1px solid var(--app-border) !important;
            color: #a1a1aa !important;
        }

        .secondary-cta:hover {
            background: rgba(34, 197, 94, 0.08) !important;
            border-color: rgba(34, 197, 94, 0.28) !important;
            color: #e4e4e7 !important;
        }

        .dashboard-title-text {
            color: #ffffff;
            letter-spacing: -0.02em;
        }

        #filter-container {
            background: rgba(255, 255, 255, 0.02) !important;
            border: 1px solid var(--app-border);
        }
        #filter-container {
            background: rgba(18, 16, 24, 0.96) !important;
            border: 1px solid rgba(34, 197, 94, 0.22) !important;
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 12px;
        }

        #filter-left-block {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 0 0 auto;
            min-width: fit-content;
        }

        #dynamic-filter-host {
            flex: 1 1 520px;
            min-width: 320px;
        }

        #dynamic-filter-controls {
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 8px;
            width: 100%;
        }

        .filter-chip {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(23, 18, 34, 0.74);
            border: 1px solid rgba(34, 197, 94, 0.32);
            border-radius: 12px;
            padding: 4px 8px;
        }

        .filter-chip-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            font-weight: 700;
            color: #c4b5fd;
        }

        .filter-chip-select,
        .filter-add-select {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(34, 197, 94, 0.32);
            color: #e9ddff;
            border-radius: 8px;
            font-size: 12px;
            padding: 5px 8px;
            outline: none;
            cursor: pointer;
        }

        .filter-chip-select:focus,
        .filter-add-select:focus {
            border-color: rgba(74, 222, 128, 0.85);
            box-shadow: 0 0 0 1px rgba(74, 222, 128, 0.28);
        }

        .filter-dropdown {
            position: relative;
            min-width: 180px;
        }

        .filter-dropdown-toggle {
            width: 100%;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(34, 197, 94, 0.32);
            color: #e9ddff;
            border-radius: 8px;
            font-size: 12px;
            padding: 5px 10px;
            outline: none;
            cursor: pointer;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .filter-dropdown-menu {
            position: fixed;
            top: -9999px;
            left: -9999px;
            min-width: 230px;
            max-width: min(360px, calc(100vw - 16px));
            background: #17191f;
            border: 1px solid rgba(34, 197, 94, 0.35);
            border-radius: 12px;
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.45);
            padding: 8px;
            z-index: 5000;
            display: none;
        }

        .filter-dropdown-menu.open {
            display: block;
        }

        .filter-dropdown-search {
            width: 100%;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(148, 163, 184, 0.35);
            color: #e9ddff;
            border-radius: 8px;
            font-size: 12px;
            padding: 6px 8px;
            outline: none;
            margin-bottom: 6px;
        }

        .filter-dropdown-options {
            max-height: 210px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .filter-dropdown-option {
            border: 1px solid rgba(34, 197, 94, 0.18);
            background: rgba(255, 255, 255, 0.02);
            color: #ddd6fe;
            border-radius: 8px;
            padding: 6px 8px;
            font-size: 12px;
            text-align: left;
            cursor: pointer;
        }

        .filter-dropdown-option:hover,
        .filter-dropdown-option.active {
            border-color: rgba(74, 222, 128, 0.7);
            background: rgba(34, 197, 94, 0.12);
            color: #fff;
        }

        .filter-dropdown-empty {
            color: #94a3b8;
            font-size: 13px;
            padding: 6px 4px;
        }

        .filter-chip-remove {
            border: none;
            background: transparent;
            color: #c4b5fd;
            font-size: 12px;
            line-height: 1;
            cursor: pointer;
            padding: 0 2px;
        }

        .filter-chip-remove:hover {
            color: #fda4af;
        }

        .filter-chip-search {
            border: 1px solid rgba(34, 197, 94, 0.32);
            background: rgba(255, 255, 255, 0.03);
            color: #e9ddff;
            border-radius: 8px;
            font-size: 13px;
            padding: 5px 8px;
            cursor: pointer;
        }

        .filter-chip-search:hover {
            border-color: rgba(74, 222, 128, 0.85);
            color: #ffffff;
        }

        .filter-clear-btn {
            padding: 6px 10px;
            font-size: 12px;
            border-radius: 8px;
            border: 1px solid rgba(34, 197, 94, 0.32);
            color: #ddd6fe;
            background: rgba(32, 22, 49, 0.62);
            cursor: pointer;
        }

        .filter-clear-btn:hover {
            border-color: rgba(251, 113, 133, 0.5);
            color: #ffe4e6;
        }

        .filter-apply-btn {
            padding: 6px 10px;
            font-size: 12px;
            border-radius: 8px;
            border: 1px solid rgba(34, 197, 94, 0.45);
            color: #dcfce7;
            background: rgba(20, 83, 45, 0.42);
            cursor: pointer;
            transition: all 0.18s ease;
        }

        .filter-apply-btn:hover {
            border-color: rgba(74, 222, 128, 0.92);
            background: rgba(22, 101, 52, 0.58);
            color: #ffffff;
        }

        .filter-apply-btn:disabled {
            cursor: not-allowed;
            opacity: 0.5;
            border-color: rgba(148, 163, 184, 0.28);
            background: rgba(30, 41, 59, 0.5);
            color: #94a3b8;
        }

        .filter-apply-btn.pending {
            box-shadow: 0 0 0 1px rgba(74, 222, 128, 0.45);
        }

        #date-filter-container {
            background: rgba(23, 18, 34, 0.74) !important;
            border: 1px solid rgba(34, 197, 94, 0.32) !important;
        }

        #date-separator {
            background: rgba(34, 197, 94, 0.32) !important;
        }

        #filter-container,
        #filter-container span,
        #filter-container p {
            color: #d6c5ff;
        }



        .filter-chip-select,
        .filter-add-select,
        .chatbot-mode,
        .edit-select {
            background-color: #17191f !important;
            color: #e4e4e7 !important;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            color-scheme: dark;
        }

        select,
        option,
        optgroup {
            background: #17191f !important;
            color: #e4e4e7 !important;
            color-scheme: dark;
        }

        .filter-chip-select option,
        .filter-add-select option,
        .chatbot-mode option,
        .edit-select option {
            background: #17191f !important;
            color: #e4e4e7 !important;
        }


        #open-charts-btn,
        #open-ai-chart-btn,
        #reset-dashboard-btn,
        #dashboard-screen button[onclick="location.reload()"] {
            background: rgba(255, 255, 255, 0.03) !important;
            border-color: var(--app-border) !important;
            color: #a1a1aa !important;
        }

        #open-charts-btn:hover,
        #open-ai-chart-btn:hover,
        #reset-dashboard-btn:hover,
        #dashboard-screen button[onclick="location.reload()"]:hover {
            background: rgba(34, 197, 94, 0.1) !important;
            border-color: rgba(34, 197, 94, 0.28) !important;
            color: #e4e4e7 !important;
        }

        .chatbot-button {
            background: var(--app-accent) !important;
        }

        .chatbot-button:hover {
            background: var(--app-accent-strong) !important;
        }

        .control-btn:hover,
        .expand-btn:hover,
        .chart-library-btn:hover,
        .chart-sidebar-clear:hover {
            background: rgba(34, 197, 94, 0.12) !important;
            border-color: rgba(34, 197, 94, 0.28) !important;
            color: #e4e4e7 !important;
        }

        .loader {
            border-top-color: var(--app-accent) !important;
        }

        .upload-zone:hover {
            border-color: rgba(139, 92, 246, 0.34) !important;
            transform: none;
        }

        .date-input-wrapper,
        .chatbot-mode,
        .chatbot-input,
        .chart-library-item,
        .chart-library-btn,
        .chart-sidebar-clear,
        .chart-sidebar-close,
        .control-btn,
        .expand-btn,
        .edit-dropdown,
        .custom-chart-sql {
            border-color: var(--app-border) !important;
        }

        .date-input-wrapper:hover,
        .date-input-wrapper:focus-within,
        .chatbot-mode:focus,
        .chatbot-input:focus,
        .edit-select:focus {
            border-color: rgba(34, 197, 94, 0.42) !important;
            box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.18);
        }

        .chatbot-dock,
        .chart-sidebar,
        .custom-chart-popup,
        .custom-kpi-popup,
        .modal-content {
            background: rgba(23, 25, 31, 0.96) !important;
            border-color: var(--app-border) !important;
            box-shadow: 0 20px 48px rgba(0, 0, 0, 0.62) !important;
        }

        .chatbot-mode,
        .chatbot-input {
            background: rgba(255, 255, 255, 0.03) !important;
            color: var(--app-text) !important;
        }

        .chatbot-status,
        .custom-chart-sql,
        .chart-sidebar-subtitle,
        .chart-library-meta {
            color: #c4b5fd !important;
        }

        .glass-panel.drop-target,
        .kpi-card.kpi-replace-target,
        .kpi-card.kpi-drop-target,
        .chart-library-item.active {
            border-color: rgba(34, 197, 94, 0.6) !important;
            box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.35), 0 12px 28px rgba(21, 128, 61, 0.34) !important;
        }

        .date-input-wrapper input[type="date"] {
            color: var(--app-text);
        }

        .chart-library-empty {
            border-color: rgba(255, 255, 255, 0.18);
            color: #9197a3;
        }

        .chart-sidebar-close:hover {
            border-color: rgba(34, 197, 94, 0.5) !important;
            background: rgba(34, 197, 94, 0.12) !important;
            color: #ecfdf3 !important;
        }



        :root {
            --app-purple: #8b5cf6;
            --app-purple-strong: #7c3aed;
            --app-purple-soft: #c4b5fd;
        }

        .widget-drag-handle {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.16s ease, background 0.16s ease, border-color 0.16s ease, color 0.16s ease;
        }

        .glass-panel:hover .widget-drag-handle,
        .kpi-card:hover .widget-drag-handle,
        .widget-drag-handle:active {
            opacity: 1;
            pointer-events: auto;
        }

        .widget-drag-handle,
        .expand-btn,
        .control-btn,
        .edit-toggle,
        .reset-toggle,
        .widget-remove-btn {
            height: 22px !important;
            min-height: 22px !important;
            padding: 4px 8px !important;
            font-size: 10px !important;
            line-height: 1 !important;
            border-radius: 8px !important;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .widget-remove-btn {
            width: auto !important;
            min-width: 22px;
            top: 10px;
            right: 8px;
        }

        .loader {
            border-top-color: var(--app-accent-strong) !important;
        }

        .expand-btn {
            background: rgba(22, 163, 74, 0.85) !important;
            border: 1px solid rgba(74, 222, 128, 0.35) !important;
        }

        .expand-btn:hover {
            background: rgba(22, 163, 74, 1) !important;
        }

        .chatbot-button {
            background: linear-gradient(90deg, #22c55e, #16a34a) !important;
        }

        .chatbot-button:hover {
            background: linear-gradient(90deg, #16a34a, #15803d) !important;
        }

        .chatbot-status,
        .custom-chart-sql {
            color: var(--app-purple-soft) !important;
        }



        .kpi-card {
            grid-template-columns: minmax(0, 1fr) 108px !important;
            gap: 10px !important;
        }

        .sparkline-container {
            width: 108px !important;
            min-width: 108px !important;
        }

        .kpi-card-content {
            min-width: 0;
            overflow: hidden;
        }

        .kpi-card .trend-badge {
            max-width: 100% !important;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: inline-flex;
        }

        .kpi-card.kpi-replace-target,
        .kpi-card.kpi-drop-target,
        .glass-panel.drop-target,
        .chart-library-item.active,
        .chart-library-btn:hover,
        .chart-sidebar-clear:hover,
        .chatbot-mode:focus,
        .chatbot-input:focus,
        .date-input-wrapper:hover,
        .date-input-wrapper:focus-within,
        .date-input-wrapper input[type="date"]:focus,
        .control-btn:hover {
            border-color: var(--app-purple-strong) !important;
        }

        .kpi-card.kpi-replace-target,
        .kpi-card.kpi-drop-target,
        .glass-panel.drop-target,
        .chart-library-item.active {
            box-shadow: 0 0 0 1px rgba(124, 58, 237, 0.45), 0 12px 28px rgba(76, 29, 149, 0.35) !important;
        }

    
.chart-insert-hint {
    position: fixed;
    right: 22px;
    bottom: 22px;
    z-index: 1350;
    background: rgba(15, 23, 42, 0.96);
    border: 1px solid rgba(148, 163, 184, 0.32);
    color: #cbd5e1;
    font-size: 13px;
    font-weight: 600;
    border-radius: 12px;
    padding: 10px 14px;
    box-shadow: 0 12px 24px rgba(2, 6, 23, 0.42);
    opacity: 0;
    transform: translateY(6px);
    pointer-events: none;
    transition: opacity 0.18s ease, transform 0.18s ease;
}

.chart-insert-hint.show {
    opacity: 1;
    transform: translateY(0);
}
    </style>
</head>
<body>

    {% csrf_token %}

        <div id="upload-screen" class="absolute inset-0 z-50 flex flex-col items-center justify-center">
        <div class="upload-zone startup-card p-12 border-2 border-dashed rounded-3xl backdrop-blur-sm text-center">
            <div class="text-6xl mb-4">Yuqta</div>
            <h1 class="text-4xl font-bold mb-4 startup-title">
                AI Dashboard 
            </h1>
            <p class="mb-6 text-sm startup-subtitle">Databricks-powered command center.</p>
            <div class="flex flex-col items-center gap-3">
                <button onclick="initDatabricksMode()" class="font-bold py-3 px-8 rounded-full transition-all shadow-lg hover:shadow-xl text-sm primary-cta">
                    Create Dashboard 
                </button>
                <button onclick="initEmptyDashboard()" class="font-semibold py-2 px-6 rounded-full transition-all text-xs secondary-cta">
                    Generate Empty Dashboard 
                </button>
            </div>
        </div>
        <div id="loader" class="hidden mt-6 flex items-center gap-3 loader-caption text-sm">
            <div class="loader"></div> Creating Dashboard
        </div>
    </div>

    <div id="dashboard-screen" class="hidden dashboard-grid">
        
        <div class="full-span flex justify-between items-center border-b border-slate-800/50 pb-2">
            <div>
                <h1 id="domain-title" class="text-3xl font-bold text-white">
                    <span id="dashboard-title-text" class="dashboard-title-text">AI Dashboard</span>
                </h1>
                <div class="flex items-center gap-4 mt-1">
                    <div class="flex items-center gap-2">
                        <span class="w-2 h-2 rounded-full bg-violet-500 pulse-dot"></span>
                        <p class="text-xs text-slate-500"><span id="session-source-label"></span></p>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-slate-500">|</span>
                        <button onclick="toggleLogs()" class="text-xs text-slate-500 hover:text-emerald-300 transition-colors">
                            View Logs
                        </button>
                    </div>
                </div>
            </div>

            <div class="flex items-center gap-3 flex-wrap justify-end">
                <button id="open-charts-btn" onclick="toggleChartSidebar()" class="px-6 py-2 bg-slate-800 rounded-xl text-xs text-slate-300 hover:bg-slate-700 border border-slate-700 transition-all hover:border-emerald-500 flex items-center gap-2">
                    Archived Charts
                </button>
                <button id="open-ai-chart-btn" onclick="toggleChatbotDock()" class="px-6 py-2 bg-slate-800 rounded-xl text-xs text-slate-300 hover:bg-slate-700 border border-slate-700 transition-all hover:border-emerald-500 flex items-center gap-2">
                    Chart Generation
                </button>
                <button id="reset-dashboard-btn" onclick="rearrangeDashboardLayout()" class="px-6 py-2 bg-slate-800 rounded-xl text-xs text-slate-300 hover:bg-slate-700 border border-slate-700 transition-all hover:border-amber-500 flex items-center gap-2">
                    Rearrange Dashboard
                </button>
                <button onclick="location.reload()" class="px-6 py-2 bg-slate-800 rounded-xl text-xs text-slate-300 hover:bg-slate-700 border border-slate-700 transition-all hover:border-emerald-500 flex items-center gap-2">
                    New Analysis
                </button>
            </div>
        </div>

                <div class="full-span bg-slate-800/30 p-3 rounded-xl filter-scroll" id="filter-container">
            <div id="filter-left-block">
                <span class="text-xs font-bold text-slate-500 uppercase flex-shrink-0 mr-2">Filters:</span>
                
                <div class="date-input-wrapper flex-shrink-0" id="date-filter-container" style="display: none;">
                    <select id="date-column-select" class="filter-chip-select date-column-select" onchange="handleDateColumnChange()"></select>
                    <input type="date" id="start-date" class="focus:outline-none cursor-pointer" onchange="handleDateChange()">
                    <span class="text-slate-500 text-xs">-></span>
                    <input type="date" id="end-date" class="focus:outline-none cursor-pointer" onchange="handleDateChange()">
                </div>
                
                <div class="w-px h-4 bg-slate-700 mx-2 flex-shrink-0" id="date-separator" style="display: none;"></div>
            </div>
            <div id="dynamic-filter-host"></div>
        </div>

        <div class="full-span grid grid-cols-4 gap-4" id="kpi-container">
        </div>

        <div id="chart_0" class="glass-panel"></div>
        <div id="chart_1" class="glass-panel"></div>

        <div id="chart_2" class="glass-panel"></div>
        <div id="chart_3" class="glass-panel"></div>
        <div id="chart_4" class="glass-panel"></div>
    </div>

    <div id="filter-loading-overlay" class="filter-loading-overlay" aria-hidden="true">
        <div class="filter-loading-card">
            <div id="filter-loading-message" class="filter-loading-title">Please wait, filters are loading...</div>
            <div class="filter-loading-track">
                <div class="filter-loading-bar"></div>
            </div>
            <div class="filter-loading-actions">
                <span id="filter-loading-note" class="filter-loading-note">Fetching filtered results from Databricks.</span>
                <button id="stop-filter-loading-btn" class="filter-loading-stop" onclick="stopFilterLoading()">Stop Loading</button>
            </div>
        </div>
    </div>

    <aside id="chart-sidebar" class="chart-sidebar" style="display: none;">
        <div class="chart-sidebar-header">
            <div>
                <div class="chart-sidebar-title">Chart Library</div>
                <div class="chart-sidebar-subtitle"><span id="chart-library-count">0</span> saved item(s)</div>
            </div>
            <div class="chart-sidebar-header-actions">
                <button class="chart-sidebar-clear" onclick="clearChartLibrary()">Clear</button>
                <button class="chart-sidebar-close" onclick="closeChartSidebar()" title="Close Chart Library">x</button>
            </div>
        </div>
        <div id="chart-library-empty" class="chart-library-empty">New and replaced charts/KPIs will appear here. Use Replace/Expand to reapply them.</div>
        <div id="chart-library-list" class="chart-library-list"></div>
    </aside>

    <div id="chart-chatbot-dock" class="chatbot-dock" style="display: none;">
        <select id="chart-request-mode" class="chatbot-mode" onchange="updateChatbotModeUI()">
            <option value="chart" selected>Chart</option>
            <option value="kpi">KPI</option>
        </select>
        <input
            id="chart-request-input"
            class="chatbot-input"
            type="text"
            placeholder="Ask for a chart in natural language (example: bar chart of total sales by region)"
            onkeydown="if(event.key === 'Enter') submitChatbotRequest()"
        >
        <button id="chart-request-btn" class="chatbot-button" onclick="submitChatbotRequest()">Generate Chart</button>
        <div id="chart-request-status" class="chatbot-status"></div>
        <button class="chatbot-close-btn" onclick="closeChatbotDock()" title="Close AI Chatbox">x</button>
    </div>

    <div id="custom-chart-popup" class="custom-chart-popup" style="display: none;">
        <div id="custom-chart-header" class="custom-chart-header">
            <div id="custom-chart-title" class="custom-chart-title">Custom Chart</div>
            <div class="popup-header-actions">
                <button class="chatbot-button popup-action-btn" onclick="insertCustomChartFromPopup()">Insert</button>
                <button class="chatbot-button popup-action-btn" onclick="enableCustomChartReplaceMode()">Replace</button>
                <button class="close-btn" onclick="closeCustomChartPopup()">Close</button>
            </div>
        </div>
        <div class="custom-chart-body">
            <div id="custom-chart-plot" class="custom-chart-plot"></div>
            <div id="custom-chart-replace-row" class="custom-replace-row" style="display:none;">
                <select id="custom-chart-replace-select" class="custom-replace-select"></select>
                <button class="chatbot-button popup-action-btn" onclick="applyCustomChartReplaceSelection()">Replace Selected</button>
            </div>
            <div class="custom-chart-note">Click Insert to add this chart, or click Replace to choose which chart to replace.</div>
            <div class="custom-chart-sql-row">
                <div id="custom-chart-sql" class="custom-chart-sql"></div>
                <button id="copy-custom-sql-btn" class="chatbot-button copy-sql-btn" onclick="copyCustomChartSql()">Copy SQL</button>
            </div>
        </div>
    </div>

    <div id="custom-kpi-popup" class="custom-kpi-popup" style="display: none;">
        <div id="custom-kpi-header" class="custom-kpi-header">
            <div id="custom-kpi-title" class="custom-chart-title">KPI</div>
            <div class="popup-header-actions">
                <button class="chatbot-button popup-action-btn" onclick="insertCustomKpiFromPopup()">Insert</button>
                <button class="chatbot-button popup-action-btn" onclick="enableCustomKpiReplaceMode()">Replace</button>
                <button class="close-btn" onclick="closeCustomKpiPopup()">Close</button>
            </div>
        </div>
        <div class="custom-kpi-body" id="custom-kpi-body"></div>
        <div id="custom-kpi-replace-row" class="custom-replace-row" style="display:none; padding: 0 10px 10px 10px;">
            <select id="custom-kpi-replace-select" class="custom-replace-select"></select>
            <button class="chatbot-button popup-action-btn" onclick="applyCustomKpiReplaceSelection()">Replace Selected</button>
        </div>
        <div class="custom-chart-note" style="padding: 0 10px 10px 10px;">Click Insert to add this KPI, or click Replace to choose which KPI to replace.</div>
    </div>

    <!-- Modal for expanded chart -->
    <div id="chart-modal" class="modal-overlay" style="display: none;" onclick="closeModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2 id="modal-title" class="text-2xl font-bold text-white">Chart</h2>
                <button class="close-btn" onclick="closeModal()">x Close</button>
            </div>
            <div class="modal-body" id="modal-chart-container">
            </div>
        </div>
    </div>

    <!-- Logs Modal -->
    <div id="logs-modal" class="modal-overlay" style="display: none;" onclick="closeLogs(event)">
        <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 900px;">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-white">Backend Logs & Table Information</h2>
                <button class="close-btn" onclick="closeLogs()">x Close</button>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                <div id="logs-content" class="font-mono text-xs space-y-2">
                </div>
            </div>
        </div>
    </div>

    <script>
        let activeFilters = {};
        let currentData = null;
        let dataSourceMode = 'databricks';
        let customPopupChart = null;
        let customPopupDragging = false;
        let customPopupOffset = { x: 0, y: 0 };
        let customPopupKpi = null;
        let customKpiPopupDragging = false;
        let customKpiPopupOffset = { x: 0, y: 0 };
        let chartSlotIds = ['chart_0', 'chart_1', 'chart_2', 'chart_3', 'chart_4'];
        let chartLibrary = [];
        let chartLibrarySeq = 0;
        let activeLibraryId = null;
        let customPopupSourceLibraryId = null;
        let customPopupKpiSourceLibraryId = null;
        let pendingKpiReplaceLibraryId = null;
        let kpiSeq = 0;
        let isChartSidebarOpen = false;
        let isChatbotDockOpen = false;
        let widgetLayouts = {};
        let widgetResizeObservers = {};
        let widgetDragState = null;
        let widgetResizeState = null;
        let availableFilterDefs = [];
        let selectedFilterColumns = [];
        let filterDropdownGlobalBound = false;
        let lastAppliedFilterSignature = '';
        let hasPendingFilterChanges = false;
        let originalDashboardState = null;
        let processAbortController = null;
        let processRequestToken = 0;
        let isFilterLoading = false;
        let userStoppedFilterLoad = false;
        let lastAppliedFilterState = {
            activeFilters: {},
            selectedFilterColumns: []
        };
        const RESERVED_FILTER_KEYS = new Set(['_start_date', '_end_date', '_date_column']);
        const FIXED_THEME = {
            color: '#22c55e',
            gradientClass: 'from-emerald-400 to-green-500'
        };

        function getThemeColor() {
            return FIXED_THEME.color;
        }

        function ensureChartSlots(requiredCount = 0) {
            const dashboard = document.getElementById('dashboard-screen');
            if (!dashboard) return;

            const target = Math.max(0, Number(requiredCount) || 0);
            while (chartSlotIds.length < target) {
                const nextId = `chart_${chartSlotIds.length}`;
                const el = document.createElement('div');
                el.id = nextId;
                el.className = 'glass-panel';
                el.style.display = 'none';

                const prevId = chartSlotIds.length ? chartSlotIds[chartSlotIds.length - 1] : null;
                const prevEl = prevId ? document.getElementById(prevId) : null;
                if (prevEl && prevEl.parentElement === dashboard) {
                    prevEl.insertAdjacentElement('afterend', el);
                } else {
                    dashboard.appendChild(el);
                }

                chartSlotIds.push(nextId);
            }
        }

        function _resolveChartSpan(chart, index, totalCount, rowSize = 4, posInRow = 0) {
            // Fill every row completely based on number of charts in that row.
            // 1 chart -> 4, 2 charts -> 2+2, 3 charts -> 2+1+1, 4 charts -> 1+1+1+1
            if (rowSize <= 1) return 4;
            if (rowSize == 2) return 2;
            if (rowSize == 3) return posInRow == 0 ? 2 : 1;
            return 1;
        }

        function _resolveChartMinHeight(chart, span, totalCount, index) {
            const raw = Number(chart && chart._layoutMinH);
            if (Number.isFinite(raw) && raw > 0) {
                return Math.max(88, Math.round(raw));
            }
            if (index === 0 && span >= 2) return 142;
            return 130;
        }

        function _buildChartRowsForCompaction(charts, maxPerRow = 4) {
            const rows = [];
            let idx = 0;

            // Initial dashboard layout: row1 has 2 charts (chart_0 + one small), row2 has 3 for 5-chart dashboard.
            if (charts.length >= 5) {
                const firstItems = charts.slice(0, 2).map((chart, pos) => ({
                    chart,
                    index: pos,
                    span: _resolveChartSpan(chart, pos, charts.length, 2, pos),
                }));
                rows.push({ start: 0, items: firstItems, count: firstItems.length, used: 4 });
                idx = 2;
            }

            while (idx < charts.length) {
                const remaining = charts.length - idx;
                let take = Math.min(maxPerRow, remaining);
                if ((remaining - take) == 1 && take > 2) {
                    take -= 1;
                }

                const items = charts.slice(idx, idx + take).map((chart, pos) => ({
                    chart,
                    index: idx + pos,
                    span: _resolveChartSpan(chart, idx + pos, charts.length, take, pos),
                }));

                rows.push({
                    start: idx,
                    items,
                    count: take,
                    used: items.reduce((s, it) => s + (it.span || 1), 0),
                });
                idx += take;
            }
            return rows;
        }

        function makeSpaceForInsertedChart(charts) {
            if (!Array.isArray(charts) || charts.length === 0) return 0;

            const maxPerRow = 4;
            const rows = _buildChartRowsForCompaction(charts, maxPerRow);
            if (!rows.length) return charts.length;

            const availableRows = rows.filter(r => r.count < maxPerRow);
            let targetRow = null;

            if (rows.length >= 2 && rows[0].count === rows[1].count && rows[0].count < maxPerRow) {
                targetRow = rows[0];
            } else if (availableRows.length) {
                targetRow = availableRows[0];
                availableRows.forEach(r => {
                    if (r.count < targetRow.count || (r.count == targetRow.count && r.start < targetRow.start)) {
                        targetRow = r;
                    }
                });
            }

            if (!targetRow) {
                // All existing rows are full -> append in a new row.
                return charts.length;
            }

            // Reduce dimensions for the target row before insertion (larger charts reduced more).
            targetRow.items.forEach(({ chart, index, span }) => {
                const currentH = _resolveChartMinHeight(chart, span, charts.length, index);
                const reduction = span >= 2 ? 24 : 14;
                chart._layoutMinH = Math.max(88, currentH - reduction);
            });

            return targetRow.start + targetRow.count;
        }

        function applyAdaptiveInsertLayout(data, options = {}) {
            const charts = Array.isArray(data?.charts) ? data.charts : [];
            const rows = _buildChartRowsForCompaction(charts, 4);
            const preferStored = options.preferStored !== false;

            const spanByIndex = new Map();
            rows.forEach((row) => {
                const desired = row.items.map((item, pos) => {
                    const fallbackSpan = _resolveChartSpan(item.chart, item.index, charts.length, row.count, pos);
                    const storedSpanRaw = Number(item.chart && item.chart._layoutSpan);
                    const storedSpan = Number.isFinite(storedSpanRaw) && storedSpanRaw > 0
                        ? Math.round(storedSpanRaw)
                        : null;
                    const base = (preferStored && storedSpan) ? storedSpan : fallbackSpan;
                    return Math.max(1, Math.min(4, base));
                });

                let used = desired.reduce((s, n) => s + n, 0);
                while (used > 4) {
                    let reduceIdx = -1;
                    let reduceSpan = 0;
                    for (let i = 0; i < desired.length; i++) {
                        if (desired[i] > 1 && desired[i] > reduceSpan) {
                            reduceSpan = desired[i];
                            reduceIdx = i;
                        }
                    }
                    if (reduceIdx < 0) break;
                    desired[reduceIdx] -= 1;
                    used -= 1;

                    const chartToShrink = row.items[reduceIdx] && row.items[reduceIdx].chart;
                    const currentH = Number(chartToShrink && chartToShrink._layoutMinH);
                    if (Number.isFinite(currentH) && currentH > 0) {
                        chartToShrink._layoutMinH = Math.max(88, Math.round(currentH - 10));
                    }
                }

                row.items.forEach((item, pos) => {
                    const span = desired[pos] || 1;
                    if (item.chart) item.chart._layoutSpan = span;
                    spanByIndex.set(item.index, span);
                });
            });

            chartSlotIds.forEach((id, idx) => {
                const panel = document.getElementById(id);
                if (!panel || panel.style.display === 'none') return;
                const chart = idx < charts.length ? charts[idx] : null;
                if (!chart) return;

                const span = spanByIndex.get(idx) || 1;
                panel.style.gridColumn = `span ${span}`;
                panel.style.minHeight = `${_resolveChartMinHeight(chart, span, charts.length, idx)}px`;
            });
        }

        const KPI_EMOJIS = {
            "total": "\uD83D\uDCCA", "revenue": "\uD83D\uDCB5", "sales": "\uD83D\uDCB0", "profit": "\uD83D\uDCC8",
            "loss": "\uD83D\uDCC9", "count": "\uD83D\uDD22", "records": "\uD83D\uDCC4", "amount": "\uD83D\uDCB2",
            "spend": "\uD83D\uDCB8", "customer": "\uD83D\uDC64", "order": "\uD83D\uDED2", "product": "\uD83D\uDCE6",
            "cost": "\uD83D\uDCB3", "price": "\uD83C\uDFF7\uFE0F", "quantity": "\uD83D\uDCCA", "employee": "\uD83D\uDC68\u200D\uD83D\uDCBC",
            "campaign": "\uD83D\uDCE3", "conversion": "\u2705", "growth": "\uD83D\uDCC8"
        };

        function getEmojiForKPI(label) {
            const lowerLabel = String(label || '').toLowerCase();
            for (const [key, icon] of Object.entries(KPI_EMOJIS)) {
                if (lowerLabel.includes(key)) return icon;
            }
            return "\uD83D\uDCCA";
        }
        function getKpiTrendWindowLabel(trendData = []) {
            const startRaw = String(activeFilters?._start_date || '').trim();
            const endRaw = String(activeFilters?._end_date || '').trim();
            const start = startRaw ? new Date(startRaw) : null;
            const end = endRaw ? new Date(endRaw) : null;

            if (start && end && !Number.isNaN(start.getTime()) && !Number.isNaN(end.getTime()) && end >= start) {
                const dayMs = 24 * 60 * 60 * 1000;
                const days = Math.max(1, Math.floor((end - start) / dayMs) + 1);
                const months = Math.max(1, Math.ceil(days / 30.4375));

                if (months >= 2 || days >= 45) {
                    return `${months} month${months === 1 ? '' : 's'}`;
                }
                return `${days} day${days === 1 ? '' : 's'}`;
            }

            const points = Array.isArray(trendData)
                ? trendData.map(v => Number(v)).filter(v => Number.isFinite(v)).length
                : 0;
            if (points >= 2) return `${points} periods`;
            return 'current period';
        }

        function formatKpiTrendBadge(trendChange, trendLabel) {
            const n = Number(trendChange);
            const safe = Number.isFinite(n) ? n : 0;
            const sign = safe >= 0 ? '+' : '-';
            const label = String(trendLabel || 'current period');
            return `${sign}${Math.abs(safe).toFixed(1)}% in ${label}`;
        }

        let chartInsertHintTimer = null;
        function showChartInsertHint(message) {
            let el = document.getElementById('chart-insert-hint');
            if (!el) {
                el = document.createElement('div');
                el.id = 'chart-insert-hint';
                el.className = 'chart-insert-hint';
                document.body.appendChild(el);
            }
            el.textContent = String(message || 'Scroll to see your added chart');
            el.classList.add('show');
            if (chartInsertHintTimer) {
                clearTimeout(chartInsertHintTimer);
            }
            chartInsertHintTimer = setTimeout(() => {
                el.classList.remove('show');
            }, 2600);
        }


        async function initDatabricksMode() {
            dataSourceMode = 'databricks';
            activeFilters = {};
            availableFilterDefs = [];
            selectedFilterColumns = [];
            chartLibrary = [];
            chartLibrarySeq = 0;
            activeLibraryId = null;
            customPopupSourceLibraryId = null;
            customPopupKpiSourceLibraryId = null;
            originalDashboardState = null;
            renderChartLibrary();
            closeCustomChartPopup();
            closeCustomKpiPopup();
            resetFilterUIForNewSession();

            processFile('initial');
        }

        function initEmptyDashboard() {
            dataSourceMode = 'databricks';
            activeFilters = {};
            availableFilterDefs = [];
            selectedFilterColumns = [];
            chartLibrary = [];
            chartLibrarySeq = 0;
            activeLibraryId = null;
            customPopupSourceLibraryId = null;
            customPopupKpiSourceLibraryId = null;
            pendingKpiReplaceLibraryId = null;
            originalDashboardState = null;

            Object.values(widgetResizeObservers || {}).forEach(ro => {
                try { if (ro) ro.disconnect(); } catch (_) {}
            });
            widgetResizeObservers = {};
            widgetLayouts = {};

            closeCustomChartPopup();
            closeCustomKpiPopup();
            closeEditMenus();
            resetFilterUIForNewSession();

            const emptyData = {
                domain: 'General',
                theme: {
                    color: FIXED_THEME.color,
                    gradient: FIXED_THEME.gradientClass
                },
                filters: [],
                kpis: [],
                charts: [],
                has_date_column: false,
                date_range: {},
                logs: [],
                tokens_used: 0,
                data_mode: 'databricks',
                session_id: null,
            };

            currentData = emptyData;
            isChartSidebarOpen = false;
            isChatbotDockOpen = true;
            renderDashboard(currentData);
            renderChartLibrary();

            originalDashboardState = {
                data: cloneDashboardPayload(currentData),
                activeFilters: {},
                selectedFilterColumns: [],
            };
            lastAppliedFilterState = {
                activeFilters: {},
                selectedFilterColumns: [],
            };
            lastAppliedFilterSignature = getFilterSignature();
            hasPendingFilterChanges = false;
            refreshApplyFiltersButton();
            const status = document.getElementById('chart-request-status');
            if (status) {
                status.textContent = 'Empty dashboard ready. Use AI Chart Generation to add charts/KPIs.';
            }
        }

        function setFilterLoadingState(active, message = 'Please wait, filters are loading...') {
            const overlay = document.getElementById('filter-loading-overlay');
            const msg = document.getElementById('filter-loading-message');
            const note = document.getElementById('filter-loading-note');
            const stopBtn = document.getElementById('stop-filter-loading-btn');

            isFilterLoading = Boolean(active);
            if (msg) msg.textContent = message;

            if (active) {
                if (note) note.textContent = 'Fetching filtered results from Databricks.';
                if (overlay) {
                    overlay.classList.add('active');
                    overlay.setAttribute('aria-hidden', 'false');
                }
                document.body.classList.add('filter-loading-active');
                if (stopBtn) {
                    stopBtn.disabled = false;
                    stopBtn.textContent = 'Stop Loading';
                }
            } else {
                if (overlay) {
                    overlay.classList.remove('active');
                    overlay.setAttribute('aria-hidden', 'true');
                }
                document.body.classList.remove('filter-loading-active');
                if (stopBtn) {
                    stopBtn.disabled = false;
                    stopBtn.textContent = 'Stop Loading';
                }
            }
            refreshApplyFiltersButton();
        }

        function setChartsLoadingOpacity(value) {
            document.querySelectorAll('.glass-panel').forEach(el => {
                el.style.opacity = String(value);
            });
        }

        function restoreLastAppliedFilterState() {
            const snapshot = lastAppliedFilterState || {};
            activeFilters = { ...(snapshot.activeFilters || {}) };
            selectedFilterColumns = Array.isArray(snapshot.selectedFilterColumns)
                ? [...snapshot.selectedFilterColumns]
                : [];

            renderEditableFilters();

            const startDate = document.getElementById('start-date');
            const endDate = document.getElementById('end-date');
            const dateRange = currentData && currentData.date_range ? currentData.date_range : {};

            if (startDate) {
                startDate.value = activeFilters['_start_date'] || dateRange.min || '';
                startDate.dataset.appliedValue = String(startDate.value || '');
            }
            if (endDate) {
                endDate.value = activeFilters['_end_date'] || dateRange.max || '';
                endDate.dataset.appliedValue = String(endDate.value || '');
            }

            const dateColSel = document.getElementById('date-column-select');
            if (dateColSel) {
                dateColSel.dataset.appliedValue = String(activeFilters['_date_column'] || dateColSel.value || '');
            }

            lastAppliedFilterSignature = getFilterSignature();
            hasPendingFilterChanges = false;
            refreshApplyFiltersButton();
            setChartsLoadingOpacity(1);
        }

        function stopFilterLoading() {
            if (!processAbortController || !isFilterLoading) return;

            const stopBtn = document.getElementById('stop-filter-loading-btn');
            const note = document.getElementById('filter-loading-note');
            if (stopBtn) {
                stopBtn.disabled = true;
                stopBtn.textContent = 'Stopping...';
            }
            if (note) note.textContent = 'Cancelling filter request...';
            userStoppedFilterLoad = true;
            processAbortController.abort();
        }

        function buildFilterRefreshWidgetsPayload() {
            const payload = { kpis: [], charts: [] };
            if (!currentData || typeof currentData !== 'object') return payload;

            const kpis = Array.isArray(currentData.kpis) ? currentData.kpis : [];
            payload.kpis = kpis.map(k => ({
                _id: ensureKpiId(k),
                label: String((k && k.label) || ''),
                sql: String((k && (k.sql || k.value_sql)) || ''),
                trend_sql: String((k && k.trend_sql) || ''),
            }));

            const charts = Array.isArray(currentData.charts) ? currentData.charts : [];
            payload.charts = charts
                .filter(c => c && !c._removed)
                .map((c, idx) => ({
                    id: String(c.id || `chart_${idx}`),
                    title: String(c.title || `Chart ${idx + 1}`),
                    type: String(c.type || 'bar'),
                    xlabel: String(c.xlabel || ''),
                    ylabel: String(c.ylabel || ''),
                    sql: String(c.sql || ''),
                    showDataLabels: Boolean(c.showDataLabels),
                }));

            return payload;
        }

        async function processFile(reason = 'manual') {
            dataSourceMode = 'databricks';
            const isFilterRequest = reason === 'filters';
            const loader = document.getElementById('loader');

            if (loader) loader.classList.remove('hidden');
            if (isFilterRequest) {
                userStoppedFilterLoad = false;
                setFilterLoadingState(true, 'Please wait, filters are loading...');
            }

            if (processAbortController) {
                try { processAbortController.abort(); } catch (_) {}
            }
            const requestToken = ++processRequestToken;
            processAbortController = new AbortController();

            const formData = new FormData();
            formData.append('filters', JSON.stringify(activeFilters));
            if (isFilterRequest) {
                formData.append('widgets', JSON.stringify(buildFilterRefreshWidgetsPayload()));
            }

            const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
            const processUrl = isFilterRequest ? '/api/reapply-filters/' : '/api/process/';

            try {
                let res = await fetch(processUrl, {
                    method: 'POST',
                    body: formData,
                    headers: {'X-CSRFToken': csrfToken},
                    signal: processAbortController.signal
                });

                if (!res.ok) throw new Error('Processing failed');
                const data = await res.json();

                if (requestToken !== processRequestToken) return;

                console.log('KPI Data:', data.kpis);
                data.kpis.forEach((kpi, idx) => {
                    console.log(`KPI ${idx} (${kpi.label}):`, kpi.sparkline);
                });

                data.charts.forEach(chart => {
                    chart.original = {
                        x: chart.x ? [...chart.x] : [],
                        y: chart.y ? [...chart.y] : [],
                        z: chart.z ? [...chart.z] : [],
                        type: chart.type,
                        xlabel: chart.xlabel,
                        ylabel: chart.ylabel,
                        title: chart.title,
                        showDataLabels: Boolean(chart.showDataLabels)
                    };
                });

                const nextData = (isFilterRequest && currentData)
                    ? mergeFilteredResponseIntoCurrentData(currentData, data)
                    : data;

                currentData = nextData;
                dataSourceMode = 'databricks';
                if (!isFilterRequest) {
                    closeCustomChartPopup();
                    closeCustomKpiPopup();
                }
                document.getElementById('chart-request-status').textContent = '';
                updateChatbotModeUI();
                renderDashboard(nextData);

                originalDashboardState = {
                    data: cloneDashboardPayload(currentData),
                    activeFilters: { ...activeFilters },
                    selectedFilterColumns: [...selectedFilterColumns],
                };
                lastAppliedFilterState = {
                    activeFilters: { ...activeFilters },
                    selectedFilterColumns: [...selectedFilterColumns],
                };
                lastAppliedFilterSignature = getFilterSignature();
                hasPendingFilterChanges = false;
                refreshApplyFiltersButton();
                setChartsLoadingOpacity(1);
            } catch (e) {
                if (e && e.name === 'AbortError') {
                    const status = document.getElementById('chart-request-status');
                    if (isFilterRequest && userStoppedFilterLoad) {
                        restoreLastAppliedFilterState();
                    }
                    if (status && isFilterRequest) {
                        status.textContent = userStoppedFilterLoad
                            ? 'Filter loading stopped. Previous filters restored.'
                            : 'Filter loading cancelled.';
                    }
                    return;
                }
                setChartsLoadingOpacity(1);
                alert('Error: ' + e.message);
            } finally {
                if (requestToken === processRequestToken) {
                    processAbortController = null;
                    if (isFilterRequest) setFilterLoadingState(false);
                    if (loader) loader.classList.add('hidden');
                    if (isFilterRequest) userStoppedFilterLoad = false;
                }
            }
        }

        function resetFilterUIForNewSession() {

            const dynamic = document.getElementById('dynamic-filter-controls');
            if (dynamic) dynamic.remove();

            const dateBox = document.getElementById('date-filter-container');
            const dateSep = document.getElementById('date-separator');
            const dateColumnSelect = document.getElementById('date-column-select');
            const startDate = document.getElementById('start-date');
            const endDate = document.getElementById('end-date');

            if (dateBox) dateBox.style.display = 'none';
            if (dateSep) dateSep.style.display = 'none';
            if (dateColumnSelect) {
                dateColumnSelect.innerHTML = '';
                dateColumnSelect.value = '';
                dateColumnSelect.dataset.appliedValue = '';
            }
            if (startDate) startDate.value = '';
            if (endDate) endDate.value = '';
        }

        function getFilterDef(column) {
            return (availableFilterDefs || []).find(f => f && f.column === column) || null;
        }

        function refreshFilterDefinitions(filters) {
            availableFilterDefs = Array.isArray(filters) ? filters : [];
            const availableCols = new Set(availableFilterDefs.map(f => f.column));

            selectedFilterColumns = selectedFilterColumns.filter(col => availableCols.has(col));

            Object.keys(activeFilters).forEach(key => {
                if (!RESERVED_FILTER_KEYS.has(key) && !availableCols.has(key)) {
                    delete activeFilters[key];
                }
            });

            Object.keys(activeFilters).forEach(key => {
                if (!RESERVED_FILTER_KEYS.has(key) && availableCols.has(key) && !selectedFilterColumns.includes(key)) {
                    selectedFilterColumns.push(key);
                }
            });

            if (selectedFilterColumns.length === 0 && availableFilterDefs.length > 0) {
                selectedFilterColumns = availableFilterDefs.slice(0, Math.min(3, availableFilterDefs.length)).map(f => f.column);
            }

            selectedFilterColumns = [...new Set(selectedFilterColumns)];
            renderEditableFilters();
        }
        function closeAllFilterDropdowns(exceptMenu = null) {
            document.querySelectorAll('.filter-dropdown-menu.open').forEach(menu => {
                if (exceptMenu && menu === exceptMenu) return;
                menu.classList.remove('open');
            });
        }

        function createSearchableFilterDropdown({
            placeholder = '',
            options = [],
            selectedValue = '',
            onSelect = null,
            searchPlaceholder = 'Search...'
        } = {}) {
            const root = document.createElement('div');
            root.className = 'filter-dropdown';

            const toggle = document.createElement('button');
            toggle.type = 'button';
            toggle.className = 'filter-dropdown-toggle';

            const menu = document.createElement('div');
            menu.className = 'filter-dropdown-menu';

            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.className = 'filter-dropdown-search';
            searchInput.placeholder = searchPlaceholder;

            const optionsBox = document.createElement('div');
            optionsBox.className = 'filter-dropdown-options';

            menu.appendChild(searchInput);
            menu.appendChild(optionsBox);
            root.appendChild(toggle);
            root.appendChild(menu);

            const positionMenu = () => {
                const rect = toggle.getBoundingClientRect();
                const menuWidth = Math.max(230, Math.ceil(rect.width));
                const estimatedHeight = Math.min(320, Math.max(120, 42 + (options.length * 30)));

                let left = rect.left;
                if (left + menuWidth > window.innerWidth - 8) {
                    left = Math.max(8, window.innerWidth - menuWidth - 8);
                }
                if (left < 8) left = 8;

                let top = rect.bottom + 6;
                if (top + estimatedHeight > window.innerHeight - 8) {
                    top = Math.max(8, rect.top - estimatedHeight - 6);
                }

                menu.style.left = `${Math.round(left)}px`;
                menu.style.top = `${Math.round(top)}px`;
                menu.style.minWidth = `${menuWidth}px`;
            };

            const onViewportChange = () => {
                if (menu.classList.contains('open')) positionMenu();
            };
            window.addEventListener('resize', onViewportChange);
            window.addEventListener('scroll', onViewportChange, true);

            let currentValue = selectedValue !== undefined && selectedValue !== null ? String(selectedValue) : '';

            const getSelectedLabel = () => {
                const found = options.find(opt => String(opt.value) === String(currentValue));
                return found ? String(found.label) : String(placeholder || 'Select');
            };

            const renderOptionList = () => {
                const q = String(searchInput.value || '').trim().toLowerCase();
                optionsBox.innerHTML = '';
                const filtered = options.filter(opt => String(opt.label || '').toLowerCase().includes(q));

                if (!filtered.length) {
                    const empty = document.createElement('div');
                    empty.className = 'filter-dropdown-empty';
                    empty.textContent = 'No matching options';
                    optionsBox.appendChild(empty);
                    return;
                }

                filtered.forEach(opt => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'filter-dropdown-option';
                    if (String(opt.value) === String(currentValue)) btn.classList.add('active');
                    btn.textContent = String(opt.label);
                    btn.onclick = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const nextVal = String(opt.value);
                        const prevVal = String(currentValue);
                        currentValue = nextVal;
                        toggle.textContent = getSelectedLabel();
                        menu.classList.remove('open');
                        if (typeof onSelect === 'function') {
                            onSelect(nextVal, prevVal, opt);
                        }
                    };
                    optionsBox.appendChild(btn);
                });
            };

            toggle.textContent = getSelectedLabel();
            toggle.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const willOpen = !menu.classList.contains('open');
                closeAllFilterDropdowns(willOpen ? menu : null);
                if (willOpen) {
                    menu.classList.add('open');
                    searchInput.value = '';
                    renderOptionList();
                    positionMenu();
                    setTimeout(() => searchInput.focus(), 0);
                } else {
                    menu.classList.remove('open');
                }
            };

            searchInput.oninput = () => renderOptionList();
            menu.addEventListener('click', (e) => e.stopPropagation());

            if (!filterDropdownGlobalBound) {
                document.addEventListener('click', () => closeAllFilterDropdowns());
                filterDropdownGlobalBound = true;
            }

            renderOptionList();
            return root;
        }

        function renderEditableFilters() {
            const filterHost = document.getElementById('dynamic-filter-host');
            if (!filterHost) return;

            const old = document.getElementById('dynamic-filter-controls');
            if (old) old.remove();

            const controls = document.createElement('div');
            controls.id = 'dynamic-filter-controls';
            controls.className = 'items-start';

            selectedFilterColumns.forEach(column => {
                const def = getFilterDef(column);
                if (!def) return;

                const label = def.label || column;
                const values = Array.isArray(def.values) ? def.values : [];
                const activeValue = activeFilters[column] !== undefined ? String(activeFilters[column]) : '';
                if (activeValue && !values.map(String).includes(activeValue)) {
                    delete activeFilters[column];
                }

                const chip = document.createElement('div');
                chip.className = 'filter-chip';

                const name = document.createElement('span');
                name.className = 'filter-chip-label';
                name.textContent = label;

                const dropdown = createSearchableFilterDropdown({
                    placeholder: `All ${label}`,
                    options: [{ value: '', label: `All ${label}` }, ...values.map(v => ({ value: String(v), label: String(v) }))],
                    selectedValue: activeFilters[column] !== undefined ? String(activeFilters[column]) : '',
                    searchPlaceholder: `Search ${label}...`,
                    onSelect: (nextVal, prevVal) => {
                        if (String(nextVal) === String(prevVal)) return;
                        if (!nextVal) delete activeFilters[column];
                        else activeFilters[column] = nextVal;
                        renderEditableFilters();
                        updateUIState();
                    }
                });

                const removeBtn = document.createElement('button');
                removeBtn.className = 'filter-chip-remove';
                removeBtn.title = `Remove ${label}`;
                removeBtn.textContent = 'x';
                removeBtn.onclick = () => removeFilterColumn(column);

                chip.appendChild(name);
                chip.appendChild(dropdown);
                chip.appendChild(removeBtn);
                controls.appendChild(chip);
            });

            const addCandidates = availableFilterDefs.filter(f => f && !selectedFilterColumns.includes(f.column));
            const addDropdown = createSearchableFilterDropdown({
                placeholder: '+ Add Filter',
                options: addCandidates.map(f => ({ value: String(f.column), label: String(f.label || f.column) })),
                selectedValue: '',
                searchPlaceholder: 'Search filter columns...',
                onSelect: (nextVal) => {
                    const col = String(nextVal || '').trim();
                    if (!col) return;
                    if (!selectedFilterColumns.includes(col)) {
                        selectedFilterColumns.push(col);
                    }
                    renderEditableFilters();
                }
            });
            controls.appendChild(addDropdown);

            if (selectedFilterColumns.length > 0) {
                const clearBtn = document.createElement('button');
                clearBtn.className = 'filter-clear-btn';
                clearBtn.textContent = 'Clear Filters';
                clearBtn.onclick = clearAllEditableFilters;
                controls.appendChild(clearBtn);
            }

            const applyBtn = document.createElement('button');
            applyBtn.id = 'apply-filters-btn';
            applyBtn.className = 'filter-apply-btn';
            applyBtn.textContent = 'Apply Filters';
            applyBtn.onclick = applyFiltersNow;
            controls.appendChild(applyBtn);

            filterHost.appendChild(controls);
            refreshApplyFiltersButton();
        }

        function handleDateColumnChange() {
            const dateColSel = document.getElementById('date-column-select');
            if (!dateColSel) return;

            const selected = String(dateColSel.value || '').trim();
            const prevSelected = String(dateColSel.dataset.appliedValue || activeFilters['_date_column'] || '').trim();
            if (selected === prevSelected) return;

            dateColSel.dataset.appliedValue = selected;
            if (selected) activeFilters['_date_column'] = selected;
            else delete activeFilters['_date_column'];

            updateUIState();
        }

        function handleFilterChange(e) {
            const col = e.target.dataset.column;
            const val = e.target.value;
            if (!col) return;

            if (val === '') delete activeFilters[col];
            else activeFilters[col] = val;

            updateUIState();
        }

        function removeFilterColumn(column) {
            const hadActiveValue = Object.prototype.hasOwnProperty.call(activeFilters, column);
            selectedFilterColumns = selectedFilterColumns.filter(c => c !== column);
            delete activeFilters[column];
            renderEditableFilters();
            if (hadActiveValue) updateUIState();
            else refreshApplyFiltersButton();
        }

        function clearAllEditableFilters() {
            selectedFilterColumns = [];
            const hadActiveValues = Object.keys(activeFilters).some(key => !RESERVED_FILTER_KEYS.has(key));
            Object.keys(activeFilters).forEach(key => {
                if (!RESERVED_FILTER_KEYS.has(key)) {
                    delete activeFilters[key];
                }
            });
            renderEditableFilters();
            if (hadActiveValues) updateUIState();
            else refreshApplyFiltersButton();
        }

        function handleDateChange() {
            const startEl = document.getElementById('start-date');
            const endEl = document.getElementById('end-date');
            if (!startEl || !endEl) return;

            const start = String(startEl.value || '');
            const end = String(endEl.value || '');
            const prevStart = String(startEl.dataset.appliedValue || activeFilters['_start_date'] || '');
            const prevEnd = String(endEl.dataset.appliedValue || activeFilters['_end_date'] || '');
            if (start === prevStart && end === prevEnd) return;

            startEl.dataset.appliedValue = start;
            endEl.dataset.appliedValue = end;

            if (start) activeFilters['_start_date'] = start;
            else delete activeFilters['_start_date'];

            if (end) activeFilters['_end_date'] = end;
            else delete activeFilters['_end_date'];

            updateUIState();
        }

        function getFilterSignature() {
            const keys = Object.keys(activeFilters || {}).sort();
            const normalized = {};
            keys.forEach(k => {
                const v = activeFilters[k];
                normalized[k] = v === undefined || v === null ? '' : String(v);
            });
            return JSON.stringify({ filters: normalized });
        }

        function updateUIState() {
            const nextSignature = getFilterSignature();
            hasPendingFilterChanges = (nextSignature !== lastAppliedFilterSignature);
            refreshApplyFiltersButton();
        }

        function refreshApplyFiltersButton() {
            const btn = document.getElementById('apply-filters-btn');
            if (!btn) return;
            const canApply = hasPendingFilterChanges && !isFilterLoading;
            btn.disabled = !canApply;
            btn.classList.toggle('pending', hasPendingFilterChanges);
        }

        function applyFiltersNow() {
            if (!hasPendingFilterChanges || isFilterLoading) return;
            setChartsLoadingOpacity(0.5);
            processFile('filters');
        }

        function createChartSnapshot(chart) {
            return {
                x: chart.x ? [...chart.x] : [],
                y: chart.y ? [...chart.y] : [],
                z: chart.z ? [...chart.z] : [],
                labels: chart.labels ? [...chart.labels] : [],
                parents: chart.parents ? [...chart.parents] : [],
                values: chart.values ? [...chart.values] : [],
                type: chart.type,
                xlabel: chart.xlabel,
                ylabel: chart.ylabel,
                title: chart.title,
                showDataLabels: Boolean(chart.showDataLabels)
            };
        }

        function cloneChart(chart) {
            return JSON.parse(JSON.stringify(chart || {}));
        }

        function cloneKpi(kpi) {
            return JSON.parse(JSON.stringify(kpi || {}));
        }

        function cloneDashboardPayload(payload) {
            return JSON.parse(JSON.stringify(payload || {}));
        }

        function _copyArrayField(source, key) {
            return Array.isArray(source && source[key])
                ? JSON.parse(JSON.stringify(source[key]))
                : [];
        }

        function _copyChartDataFields(targetChart, sourceChart) {
            const keys = ['x', 'y', 'z', 'columns', 'rows', 'labels', 'parents', 'values', 'measure'];
            keys.forEach(key => {
                targetChart[key] = _copyArrayField(sourceChart, key);
            });
        }

        function mergeFilteredResponseIntoCurrentData(existingData, filteredData) {
            if (!filteredData) return cloneDashboardPayload(existingData || {});
            if (!existingData) return cloneDashboardPayload(filteredData || {});

            const merged = cloneDashboardPayload(existingData);

            merged.domain = filteredData.domain || merged.domain;
            merged.theme = filteredData.theme || merged.theme;
            merged.filters = Array.isArray(filteredData.filters) ? cloneDashboardPayload(filteredData.filters) : (merged.filters || []);
            const priorLogs = Array.isArray(merged.logs) ? [...merged.logs] : [];
            const incomingLogs = Array.isArray(filteredData.logs) ? [...filteredData.logs] : [];
            const combinedLogs = priorLogs.concat(incomingLogs);
            const dedupedLogs = [];
            for (let i = 0; i < combinedLogs.length; i++) {
                const line = String(combinedLogs[i] ?? '');
                if (!line) continue;
                if (dedupedLogs.length > 0 && dedupedLogs[dedupedLogs.length - 1] === line) continue;
                dedupedLogs.push(line);
            }
            merged.logs = dedupedLogs.slice(-1500);
            merged.tokens_used = Number(filteredData.tokens_used || 0);
            merged.date_range = filteredData.date_range || merged.date_range || {};
            merged.date_columns = Array.isArray(filteredData.date_columns) ? [...filteredData.date_columns] : (merged.date_columns || []);
            merged.selected_date_column = filteredData.selected_date_column || merged.selected_date_column || '';
            merged.has_date_column = Boolean(filteredData.has_date_column);
            merged.data_mode = filteredData.data_mode || merged.data_mode;
            merged.source_table = filteredData.source_table || merged.source_table;
            merged.session_id = filteredData.session_id || merged.session_id;

            const incomingKpis = Array.isArray(filteredData.kpis) ? filteredData.kpis : [];
            if (!Array.isArray(merged.kpis) || merged.kpis.length === 0) {
                merged.kpis = incomingKpis.map(k => cloneKpi(k));
            } else {
                let kpiIdx = 0;
                merged.kpis = merged.kpis.map(existingKpi => {
                    const keep = cloneKpi(existingKpi);
                    const source = incomingKpis[kpiIdx] || null;
                    if (!source) return keep;
                    kpiIdx += 1;
                    if (source._refresh_failed) return keep;
                    if ((keep.label === undefined || keep.label === null || String(keep.label).trim() === '') && source.label) {
                        keep.label = source.label;
                    }
                    keep.value = source.value;
                    keep.sparkline = Array.isArray(source.sparkline) ? [...source.sparkline] : [];
                    if (source.sql !== undefined) keep.sql = source.sql;
                    if (source.trend_sql !== undefined) keep.trend_sql = source.trend_sql;
                    return keep;
                });
            }

            const incomingCharts = Array.isArray(filteredData.charts) ? filteredData.charts : [];
            if (!Array.isArray(merged.charts) || merged.charts.length === 0) {
                merged.charts = incomingCharts.map((c, i) => {
                    const next = cloneChart(c);
                    next.id = next.id || `chart_${i}`;
                    next.original = createChartSnapshot(next);
                    return next;
                });
            } else {
                let sourceIdx = 0;
                merged.charts = merged.charts.map(existingChart => {
                    const keep = cloneChart(existingChart);
                    if (!keep || keep._removed) return keep;

                    const source = incomingCharts[sourceIdx] || null;
                    if (!source) return keep;
                    sourceIdx += 1;
                    if (source._refresh_failed) return keep;

                    _copyChartDataFields(keep, source);
                    if (source.sql !== undefined) keep.sql = source.sql;
                    if (!keep.title && source.title) keep.title = source.title;
                    if (!keep.xlabel && source.xlabel) keep.xlabel = source.xlabel;
                    if (!keep.ylabel && source.ylabel) keep.ylabel = source.ylabel;
                    keep.original = createChartSnapshot(keep);
                    return keep;
                });
            }

            return merged;
        }

        function ensureKpiId(kpi) {
            if (!kpi) return '';
            if (kpi._id) {
                const idText = String(kpi._id);
                const m = idText.match(/^kpi_(\d+)$/i);
                if (m) {
                    kpiSeq = Math.max(kpiSeq, Number(m[1]) || 0);
                }
                return idText;
            }
            kpi._id = `kpi_${++kpiSeq}`;
            return kpi._id;
        }

        function chartTypeLabel(type) {
            const t = (type || '').toLowerCase();
            if (t === 'kpi') return 'KPI';
            if (t === 'line') return 'Line';
            if (t === 'bar') return 'Bar';
            if (t === 'scatter') return 'Scatter';
            if (t === 'heatmap') return 'Heatmap';
            if (t === 'pie') return 'Pie';
            if (t === 'table') return 'Table';
            if (t === 'treemap') return 'Treemap';
            if (t === 'waterfall') return 'Waterfall';
            return type || 'Chart';
        }

        function applyWidgetLayoutToElement(el, widgetId) {
            if (!el || !widgetId) return;
            const layout = widgetLayouts[widgetId];
            if (!layout || !layout.manual) {
                el.style.transform = '';
                el.style.width = '';
                el.style.height = '';
                return;
            }

            const x = Number(layout.x) || 0;
            const y = Number(layout.y) || 0;
            el.style.transform = `translate(${x}px, ${y}px)`;
            el.style.width = Number(layout.w) > 0 ? `${Math.max(140, Number(layout.w))}px` : '';
            el.style.height = Number(layout.h) > 0 ? `${Math.max(90, Number(layout.h))}px` : '';
        }

        function saveWidgetSize(widgetId, el) {
            if (!widgetId || !el) return;
            if (!widgetLayouts[widgetId] || !widgetLayouts[widgetId].manual) return;
            widgetLayouts[widgetId].w = el.offsetWidth;
            widgetLayouts[widgetId].h = el.offsetHeight;
        }

        function resizeChartPlot(chartId) {
            const plotEl = document.getElementById(`plot-${chartId}`);
            if (!plotEl || typeof Plotly === 'undefined') return;
            try {
                Plotly.Plots.resize(plotEl);
            } catch (_) {}
        }

        function getWidgetResizeEdge(el, event) {
            const rect = el.getBoundingClientRect();
            const edgeSize = 8;
            const localX = event.clientX - rect.left;
            const localY = event.clientY - rect.top;
            const onLeft = localX >= 0 && localX <= edgeSize;
            const onRight = localX >= (rect.width - edgeSize) && localX <= rect.width;
            const onTop = localY >= 0 && localY <= edgeSize;
            const onBottom = localY >= (rect.height - edgeSize) && localY <= rect.height;

            let vertical = '';
            let horizontal = '';
            if (onTop) vertical = 'n';
            else if (onBottom) vertical = 's';
            if (onLeft) horizontal = 'w';
            else if (onRight) horizontal = 'e';
            return `${vertical}${horizontal}`;
        }

        function getWidgetResizeCursor(edge) {
            const map = {
                n: 'ns-resize',
                s: 'ns-resize',
                e: 'ew-resize',
                w: 'ew-resize',
                ne: 'nesw-resize',
                sw: 'nesw-resize',
                nw: 'nwse-resize',
                se: 'nwse-resize'
            };
            return map[edge] || '';
        }

        function isWidgetInteractiveTarget(target) {
            if (!target) return false;
            return Boolean(target.closest('button, input, select, textarea, a, .chart-controls, .edit-dropdown, .widget-drag-handle'));
        }

        function onWidgetEdgeHover(event) {
            if (widgetDragState || widgetResizeState) return;
            const el = event.currentTarget;
            if (!el) return;
            const edge = getWidgetResizeEdge(el, event);
            el.style.cursor = getWidgetResizeCursor(edge) || 'default';
        }

        function onWidgetEdgeLeave(event) {
            if (widgetResizeState || widgetDragState) return;
            const el = event.currentTarget;
            if (el) el.style.cursor = 'default';
        }

        function onWidgetResizeMouseDown(event) {
            if (event.button !== 0) return;
            if (widgetDragState || widgetResizeState) return;
            if (isWidgetInteractiveTarget(event.target)) return;

            const el = event.currentTarget;
            if (!el) return;
            const widgetId = el.dataset.widgetId;
            const kind = el.dataset.widgetKind || 'chart';
            if (!widgetId) return;

            const edge = getWidgetResizeEdge(el, event);
            if (!edge) return;

            startWidgetResize(event, widgetId, edge, kind);
        }

        function initWidgetInteractionsForElement(el, widgetId, kind = 'chart') {
            if (!el || !widgetId) return;
            el.dataset.widgetId = widgetId;
            el.dataset.widgetKind = kind;
            applyWidgetLayoutToElement(el, widgetId);
            saveWidgetSize(widgetId, el);

            if (el.dataset.widgetInteractionBound !== '1') {
                el.dataset.widgetInteractionBound = '1';
                el.addEventListener('mousemove', onWidgetEdgeHover);
                el.addEventListener('mouseleave', onWidgetEdgeLeave);
                el.addEventListener('mousedown', onWidgetResizeMouseDown);
            }

            if (kind === 'chart') {
                if (typeof ResizeObserver !== 'undefined') {
                    if (widgetResizeObservers[widgetId]) {
                        try { widgetResizeObservers[widgetId].disconnect(); } catch (_) {}
                    }
                    const ro = new ResizeObserver(() => resizeChartPlot(widgetId));
                    ro.observe(el);
                    widgetResizeObservers[widgetId] = ro;
                }
                setTimeout(() => resizeChartPlot(widgetId), 30);
            }
        }

        function startWidgetResize(event, widgetId, edge, kind) {
            const el = document.getElementById(widgetId);
            if (!el) return;

            event.preventDefault();
            event.stopPropagation();

            const layout = widgetLayouts[widgetId] || { x: 0, y: 0, w: el.offsetWidth, h: el.offsetHeight };
            widgetLayouts[widgetId] = layout;

            widgetResizeState = {
                widgetId,
                edge,
                kind,
                startX: event.clientX,
                startY: event.clientY,
                baseX: Number(layout.x) || 0,
                baseY: Number(layout.y) || 0,
                baseW: Number(layout.w) || el.offsetWidth,
                baseH: Number(layout.h) || el.offsetHeight,
                minW: kind === 'kpi' ? 220 : 260,
                minH: kind === 'kpi' ? 90 : 120,
            };

            el.style.cursor = getWidgetResizeCursor(edge);
            document.addEventListener('mousemove', onWidgetResizeMove);
            document.addEventListener('mouseup', onWidgetResizeEnd);
        }

        function onWidgetResizeMove(event) {
            if (!widgetResizeState) return;
            const {
                widgetId,
                edge,
                startX,
                startY,
                baseX,
                baseY,
                baseW,
                baseH,
                minW,
                minH,
                kind
            } = widgetResizeState;

            const el = document.getElementById(widgetId);
            if (!el) return;

            const dx = event.clientX - startX;
            const dy = event.clientY - startY;

            let nextX = baseX;
            let nextY = baseY;
            let nextW = baseW;
            let nextH = baseH;

            if (edge.includes('e')) nextW = baseW + dx;
            if (edge.includes('s')) nextH = baseH + dy;
            if (edge.includes('w')) {
                nextW = baseW - dx;
                nextX = baseX + dx;
            }
            if (edge.includes('n')) {
                nextH = baseH - dy;
                nextY = baseY + dy;
            }

            if (nextW < minW) {
                if (edge.includes('w')) nextX -= (minW - nextW);
                nextW = minW;
            }
            if (nextH < minH) {
                if (edge.includes('n')) nextY -= (minH - nextH);
                nextH = minH;
            }

            widgetLayouts[widgetId] = {
                ...(widgetLayouts[widgetId] || {}),
                manual: true,
                x: nextX,
                y: nextY,
                w: nextW,
                h: nextH,
            };

            applyWidgetLayoutToElement(el, widgetId);
            if (kind === 'chart') {
                resizeChartPlot(widgetId);
            }
        }

        function onWidgetResizeEnd() {
            if (!widgetResizeState) return;
            const { widgetId } = widgetResizeState;
            const el = document.getElementById(widgetId);
            if (el) {
                saveWidgetSize(widgetId, el);
                el.style.cursor = 'default';
                if (widgetId.startsWith('chart_')) {
                    resizeChartPlot(widgetId);
                }
            }

            widgetResizeState = null;
            document.removeEventListener('mousemove', onWidgetResizeMove);
            document.removeEventListener('mouseup', onWidgetResizeEnd);
        }

        function startWidgetDrag(event, widgetId) {
            const el = document.getElementById(widgetId);
            if (!el) return;

            event.preventDefault();
            event.stopPropagation();

            const layout = widgetLayouts[widgetId] || { x: 0, y: 0, w: el.offsetWidth, h: el.offsetHeight };
            widgetLayouts[widgetId] = layout;

            widgetDragState = {
                widgetId,
                startX: event.clientX,
                startY: event.clientY,
                baseX: Number(layout.x) || 0,
                baseY: Number(layout.y) || 0,
            };

            document.addEventListener('mousemove', onWidgetDragMove);
            document.addEventListener('mouseup', onWidgetDragEnd);
        }

        function onWidgetDragMove(event) {
            if (!widgetDragState) return;
            const { widgetId, startX, startY, baseX, baseY } = widgetDragState;
            const el = document.getElementById(widgetId);
            if (!el) return;

            const dx = event.clientX - startX;
            const dy = event.clientY - startY;
            const nextX = baseX + dx;
            const nextY = baseY + dy;

            if (!widgetLayouts[widgetId]) widgetLayouts[widgetId] = {};
            widgetLayouts[widgetId].manual = true;
            widgetLayouts[widgetId].x = nextX;
            widgetLayouts[widgetId].y = nextY;

            applyWidgetLayoutToElement(el, widgetId);
        }

        function onWidgetDragEnd() {
            if (!widgetDragState) return;
            const { widgetId } = widgetDragState;
            const el = document.getElementById(widgetId);
            if (el) {
                saveWidgetSize(widgetId, el);
                if (widgetId.startsWith('chart_')) {
                    resizeChartPlot(widgetId);
                }
            }

            widgetDragState = null;
            document.removeEventListener('mousemove', onWidgetDragMove);
            document.removeEventListener('mouseup', onWidgetDragEnd);
        }

        function escapeHtml(value) {
            return String(value || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function updateChartsToggleButton() {
            const btn = document.getElementById('open-charts-btn');
            if (!btn) return;
            btn.textContent = isChartSidebarOpen ? 'Close Charts' : 'Open Charts';
        }

        function updateChatbotDockVisibility() {
            const dock = document.getElementById('chart-chatbot-dock');
            const btn = document.getElementById('open-ai-chart-btn');
            const dashboard = document.getElementById('dashboard-screen');
            if (!dock || !btn || !dashboard) return;

            const showDock = isChatbotDockOpen && !dashboard.classList.contains('hidden');
            dock.style.display = showDock ? 'flex' : 'none';
            dashboard.classList.remove('with-chatbot-dock');
            btn.textContent = isChatbotDockOpen ? 'Close AI Chart' : 'AI Chart Generation';
        }

        function updateChatbotModeUI() {
            const modeEl = document.getElementById('chart-request-mode');
            const inputEl = document.getElementById('chart-request-input');
            const btnEl = document.getElementById('chart-request-btn');
            if (!modeEl || !inputEl || !btnEl) return;

            const mode = (modeEl.value || 'chart').toLowerCase();
            if (mode === 'kpi') {
                inputEl.placeholder = 'Ask for a KPI (example: total revenue with monthly sparkline)';
                btnEl.textContent = 'Add KPI';
            } else {
                inputEl.placeholder = 'Ask for a chart in natural language (example: bar chart of total sales by region)';
                btnEl.textContent = 'Generate Chart';
            }
        }

        function submitChatbotRequest() {
            const modeEl = document.getElementById('chart-request-mode');
            const mode = modeEl ? String(modeEl.value || 'chart').toLowerCase() : 'chart';
            if (mode === 'kpi') {
                return submitCustomKpiRequest();
            }
            return submitCustomChartRequest();
        }

        function toggleChatbotDock(forceOpen = null) {
            if (typeof forceOpen === 'boolean') {
                isChatbotDockOpen = forceOpen;
            } else {
                isChatbotDockOpen = !isChatbotDockOpen;
            }

            updateChatbotDockVisibility();
            updateChatbotModeUI();

            if (isChatbotDockOpen) {
                const input = document.getElementById('chart-request-input');
                if (input) {
                    setTimeout(() => input.focus(), 50);
                }
            }
        }

        function closeChatbotDock() {
            isChatbotDockOpen = false;
            updateChatbotDockVisibility();
        }

        function rearrangeDashboardLayout() {
            if (!currentData) {
                const status = document.getElementById('chart-request-status');
                if (status) status.textContent = 'No dashboard data available to rearrange.';
                return;
            }

            closeCustomChartPopup();
            closeCustomKpiPopup();
            closeEditMenus();

            Object.values(widgetResizeObservers || {}).forEach(ro => {
                try { if (ro) ro.disconnect(); } catch (_) {}
            });
            widgetResizeObservers = {};
            widgetLayouts = {};
            widgetDragState = null;
            widgetResizeState = null;

            const keptCharts = Array.isArray(currentData.charts)
                ? currentData.charts
                    .filter(c => c && !c._removed && hasRenderableChartData(c))
                    .map(c => {
                        const copy = cloneChart(c);
                        delete copy._removed;
                        return copy;
                    })
                : [];

            const keptKpis = Array.isArray(currentData.kpis)
                ? currentData.kpis
                    .filter(k => k && (String(k.label || '').trim() || String(k.value || '').trim() || (Array.isArray(k.sparkline) && k.sparkline.length > 0)))
                    .map(k => cloneKpi(k))
                : [];

            currentData.charts = keptCharts;
            currentData.kpis = keptKpis;

            renderDashboard(currentData);

            const status = document.getElementById('chart-request-status');
            if (status) {
                status.textContent = 'Dashboard rearranged using current charts and KPIs only.';
            }
        }

        function toggleChartSidebar() {
            isChartSidebarOpen = !isChartSidebarOpen;
            updateChartsToggleButton();
            updateDashboardSidebarLayout();
        }

        function closeChartSidebar() {
            if (!isChartSidebarOpen) return;
            isChartSidebarOpen = false;
            updateChartsToggleButton();
            updateDashboardSidebarLayout();
        }

        function updateDashboardSidebarLayout() {
            const dashboard = document.getElementById('dashboard-screen');
            const sidebar = document.getElementById('chart-sidebar');
            if (!dashboard || !sidebar) return;

            if (dashboard.classList.contains('hidden') || !isChartSidebarOpen) {
                sidebar.style.display = 'none';
                dashboard.classList.remove('with-sidebar');
                return;
            }

            sidebar.style.display = 'flex';
            if (window.innerWidth > 1250) {
                dashboard.classList.add('with-sidebar');
            } else {
                dashboard.classList.remove('with-sidebar');
            }
        }

        function renderChartLibrary() {
            const list = document.getElementById('chart-library-list');
            const empty = document.getElementById('chart-library-empty');
            const count = document.getElementById('chart-library-count');
            if (!list || !empty || !count) return;

            count.textContent = String(chartLibrary.length);
            updateChartsToggleButton();
            list.innerHTML = '';

            if (chartLibrary.length === 0) {
                empty.style.display = 'block';
                return;
            }

            empty.style.display = 'none';

            chartLibrary.forEach(entry => {
                const item = document.createElement('div');
                item.className = `chart-library-item ${entry.id === activeLibraryId ? 'active' : ''}`;
                const isKpi = entry.artifact === 'kpi';
                const metaType = isKpi ? 'KPI' : chartTypeLabel(entry.type);
                const useLabel = 'Insert';
                const expandHandler = isKpi ? `openLibraryKpiModal('${entry.id}')` : `openLibraryChartModal('${entry.id}')`;
                const useHandler = isKpi ? `useLibraryKpi('${entry.id}')` : `useLibraryChart('${entry.id}')`;
                const replaceBtn = isKpi
                    ? `<button class="chart-library-btn" onclick="openLibraryKpiReplace('${entry.id}')">Replace</button>`
                    : `<button class="chart-library-btn" onclick="openLibraryChartInPopup('${entry.id}', true)">Replace</button>`;

                item.innerHTML = `
                    <div class="chart-library-title">${escapeHtml(entry.title)}</div>
                    <div class="chart-library-meta">${escapeHtml(entry.source)} | ${escapeHtml(metaType)}</div>
                    <div class="chart-library-actions">
                        <button class="chart-library-btn" onclick="${useHandler}">${useLabel}</button>
                        ${replaceBtn}
                        <button class="chart-library-btn" onclick="${expandHandler}">Expand</button>
                        <button class="chart-library-btn" onclick="removeLibraryChart('${entry.id}')">Delete</button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        function addChartToLibrary(chart, options = {}) {
            if (!chart) return null;

            const chartClone = cloneChart(chart);
            delete chartClone.id;
            delete chartClone.original;

            const entry = {
                id: `lib_${++chartLibrarySeq}`,
                artifact: 'chart',
                title: chartClone.title || options.title || `Chart ${chartLibrarySeq}`,
                type: chartClone.type || 'bar',
                source: options.source || 'Generated',
                sql: options.sql || '',
                chart: chartClone,
                createdAt: Date.now()
            };

            chartLibrary.unshift(entry);
            activeLibraryId = entry.id;
            renderChartLibrary();
            return entry;
        }

        function addKpiToLibrary(kpi, options = {}) {
            if (!kpi) return null;
            const kpiClone = cloneKpi(kpi);
            ensureKpiId(kpiClone);

            const sqlValue = options.sql || '';
            const sqlText = typeof sqlValue === 'string' ? sqlValue : JSON.stringify(sqlValue);

            const entry = {
                id: `lib_${++chartLibrarySeq}`,
                artifact: 'kpi',
                title: kpiClone.label || options.title || `KPI ${chartLibrarySeq}`,
                type: 'kpi',
                source: options.source || 'Generated',
                sql: sqlText,
                kpi: kpiClone,
                createdAt: Date.now()
            };

            chartLibrary.unshift(entry);
            activeLibraryId = entry.id;
            renderChartLibrary();
            return entry;
        }

        function removeLibraryChart(libraryId) {
            chartLibrary = chartLibrary.filter(item => item.id !== libraryId);
            if (activeLibraryId === libraryId) activeLibraryId = null;
            if (pendingKpiReplaceLibraryId === libraryId) pendingKpiReplaceLibraryId = null;
            renderChartLibrary();
            refreshKpiReplaceTargets();
        }

        function clearChartLibrary() {
            chartLibrary = [];
            activeLibraryId = null;
            pendingKpiReplaceLibraryId = null;
            renderChartLibrary();
            refreshKpiReplaceTargets();
        }

        function openLibraryKpiModal(libraryId) {
            const entry = chartLibrary.find(item => item.id === libraryId);
            if (!entry || entry.artifact !== 'kpi' || !entry.kpi || !currentData) return;

            activeLibraryId = libraryId;
            renderChartLibrary();

            const modal = document.getElementById('chart-modal');
            const modalContainer = document.getElementById('modal-chart-container');
            const modalTitle = document.getElementById('modal-title');
            const color = getThemeColor();
            const trendData = Array.isArray(entry.kpi.sparkline) ? entry.kpi.sparkline : [];
            const trendChange = calculateTrend(trendData);
            const isPositive = trendChange >= 0;
            const trendWindowLabel = getKpiTrendWindowLabel(trendData);
            const sparkId = `library-kpi-spark-${Date.now()}`;

            modalTitle.textContent = `${entry.title} (KPI)`;
            modalContainer.innerHTML = `
                <div class="kpi-card" style="border-left-color:${color}; max-width: 440px; margin: 10px auto; resize:none; transform:none; min-height: 130px;">
                    <div class="kpi-card-content">
<div class="text-[10px] uppercase text-slate-300 font-bold tracking-wider">${escapeHtml(entry.kpi.label || 'KPI')}</div>
                        <div class="text-3xl font-bold text-white mt-1 mb-1">${escapeHtml(entry.kpi.value || '0')}</div>
                        <div class="trend-badge ${isPositive ? 'trend-up' : 'trend-down'}">
                            ${formatKpiTrendBadge(trendChange, trendWindowLabel)}
                        </div>
                    </div>
                    <div class="sparkline-container" id="${sparkId}"></div>
                </div>
            `;

            modal.style.display = 'flex';
            setTimeout(() => {
                const trendColor = '#8b5cf6';
                createSparkline(sparkId, trendData.length ? trendData : [0, 0, 0, 0, 0, 0], trendColor);
            }, 80);
        }

        function openLibraryKpiReplace(libraryId) {
            const entry = chartLibrary.find(item => item.id === libraryId);
            if (!entry || entry.artifact !== 'kpi') return;

            pendingKpiReplaceLibraryId = libraryId;
            activeLibraryId = libraryId;
            customPopupSourceLibraryId = null;
            closeCustomChartPopup();
            openCustomKpiPopup(entry);
            enableCustomKpiReplaceMode();
            renderChartLibrary();
            refreshKpiReplaceTargets();

            const status = document.getElementById('chart-request-status');
            if (status) {
                status.textContent = `Choose the KPI card to replace with "${entry.title}".`;
            }
        }


        function insertChartWithoutGlobalRelayout(chartInput) {
            if (!currentData) return null;
            if (!Array.isArray(currentData.charts)) currentData.charts = [];

            const nextChart = cloneChart(chartInput);
            delete nextChart.id;
            nextChart._layoutSpan = Number(nextChart._layoutSpan) > 0 ? Number(nextChart._layoutSpan) : 1;
            nextChart._layoutMinH = Number(nextChart._layoutMinH) > 0 ? Number(nextChart._layoutMinH) : 120;
            nextChart.original = createChartSnapshot(nextChart);

            const emptyIdx = currentData.charts.findIndex(c => c && c._removed === true);
            if (emptyIdx !== -1) {
                const slotId = currentData.charts[emptyIdx].id || chartSlotIds[emptyIdx] || ('chart_' + emptyIdx);
                nextChart.id = slotId;
                currentData.charts[emptyIdx] = nextChart;
                renderChartById(slotId);
                return slotId;
            }

            const visibleBefore = currentData.charts.filter(c => c && c._removed !== true).length;
            const rowOneTwoCapacity = 5;
            const forcedToRow3 = visibleBefore >= rowOneTwoCapacity;

            currentData.charts.push(nextChart);
            ensureChartSlots(currentData.charts.length);
            const newIndex = currentData.charts.length - 1;
            const slotId = chartSlotIds[newIndex] || ('chart_' + newIndex);
            nextChart.id = slotId;

            const slot = document.getElementById(slotId);
            if (slot) {
                slot.style.display = 'flex';
                slot.style.gridColumn = slot.style.gridColumn || 'span 1';
                if (!slot.style.minHeight) slot.style.minHeight = (Math.max(88, nextChart._layoutMinH) + 'px');
            }

            renderChartById(slotId);

            if (forcedToRow3) {
                const dashboard = document.getElementById('dashboard-screen');
                if (dashboard) {
                    dashboard.style.overflowY = 'auto';
                    dashboard.style.overflowX = 'hidden';
                }
                showChartInsertHint('Scroll to see your added chart');
            }

            return slotId;
        }

        function useLibraryChart(libraryId) {
            const entry = chartLibrary.find(item => item.id === libraryId);
            if (!entry || entry.artifact === 'kpi' || !entry.chart || !currentData) return;

            if (!Array.isArray(currentData.charts)) {
                currentData.charts = [];
            }

            activeLibraryId = libraryId;
            pendingKpiReplaceLibraryId = null;
            customPopupSourceLibraryId = null;
            closeCustomKpiPopup();

            insertChartWithoutGlobalRelayout(entry.chart);
            renderChartLibrary();

            const status = document.getElementById('chart-request-status');
            if (status) {
                status.textContent = `Inserted "${entry.title}" on dashboard.`;
            }
        }

        function useLibraryKpi(libraryId) {
            const entry = chartLibrary.find(item => item.id === libraryId);
            if (!entry || entry.artifact !== 'kpi' || !entry.kpi || !currentData) return;

            if (!Array.isArray(currentData.kpis)) {
                currentData.kpis = [];
            }

            activeLibraryId = libraryId;
            customPopupSourceLibraryId = null;
            closeCustomChartPopup();
            closeCustomKpiPopup();

            const kpiToAdd = cloneKpi(entry.kpi);
            delete kpiToAdd._id;
            ensureKpiId(kpiToAdd);
            currentData.kpis.push(kpiToAdd);

            renderKpisSection(currentData, getThemeColor());
            renderChartLibrary();

            const status = document.getElementById('chart-request-status');
            if (status) {
                status.textContent = `Inserted KPI "${entry.title}" on dashboard.`;
            }
        }

        function openLibraryChartModal(libraryId) {
            const entry = chartLibrary.find(item => item.id === libraryId);
            if (!entry || !currentData) return;
            if (entry.artifact === 'kpi') {
                openLibraryKpiModal(libraryId);
                return;
            }

            activeLibraryId = libraryId;
            renderChartLibrary();

            const modal = document.getElementById('chart-modal');
            const modalContainer = document.getElementById('modal-chart-container');
            const modalTitle = document.getElementById('modal-title');

            const chart = cloneChart(entry.chart);
            modalTitle.textContent = `${entry.title}`;
            modalContainer.innerHTML = '';

            const chartDiv = document.createElement('div');
            chartDiv.style.width = '100%';
            chartDiv.style.height = '100%';
            modalContainer.appendChild(chartDiv);

            const color = getThemeColor();
            modal.style.display = 'flex';

            setTimeout(() => {
                renderSingleChart(chartDiv, chart, color, true);
            }, 120);
        }

        function openLibraryChartInPopup(libraryId, startReplaceMode = false) {
            const entry = chartLibrary.find(item => item.id === libraryId);
            if (!entry || entry.artifact === 'kpi') return;

            pendingKpiReplaceLibraryId = null;
            activeLibraryId = libraryId;
            customPopupSourceLibraryId = libraryId;
            customPopupChart = cloneChart(entry.chart);
            customPopupChart.original = createChartSnapshot(customPopupChart);

            openCustomChartPopup(entry.sql || '');
            if (startReplaceMode) {
                enableCustomChartReplaceMode();
            }
            const status = document.getElementById('chart-request-status');
            status.textContent = startReplaceMode
                ? 'Select a chart and click Replace Selected.'
                : 'Click Insert to add this chart, or click Replace to choose a chart to replace.';
            renderChartLibrary();
        }

        function getKpiById(kpiId) {
            if (!currentData || !Array.isArray(currentData.kpis)) return null;
            return currentData.kpis.find(k => ensureKpiId(k) === kpiId) || null;
        }

        function handleKpiCardClick(kpiId) {
            if (!pendingKpiReplaceLibraryId) return;
            applyLibraryKpiToSlot(kpiId);
        }


        function refreshKpiReplaceTargets() {
            document.querySelectorAll('#kpi-container .kpi-card').forEach(el => {
                if (pendingKpiReplaceLibraryId) el.classList.add('kpi-replace-target');
                else el.classList.remove('kpi-replace-target');
            });
        }

        function applyLibraryKpiToSlot(kpiId) {
            if (!currentData || !Array.isArray(currentData.kpis) || !pendingKpiReplaceLibraryId) return;

            let sourceKpi = null;
            if (customPopupKpi) {
                sourceKpi = cloneKpi(customPopupKpi);
            } else {
                const entry = chartLibrary.find(item => item.id === pendingKpiReplaceLibraryId);
                if (entry && entry.artifact === 'kpi' && entry.kpi) {
                    sourceKpi = cloneKpi(entry.kpi);
                }
            }
            if (!sourceKpi) return;

            const targetIndex = currentData.kpis.findIndex(k => ensureKpiId(k) === kpiId);
            if (targetIndex === -1) return;

            const replaced = cloneKpi(currentData.kpis[targetIndex]);
            if (replaced) {
                addKpiToLibrary(replaced, { source: `Replaced ${kpiId}` });
            }

            sourceKpi._id = kpiId;
            currentData.kpis[targetIndex] = sourceKpi;

            pendingKpiReplaceLibraryId = null;
            customPopupKpi = null;
            renderKpisSection(currentData, getThemeColor());
            closeCustomKpiPopup();
            refreshKpiReplaceTargets();
            renderChartLibrary();

            const status = document.getElementById('chart-request-status');
            if (status) {
                status.textContent = `Replaced ${kpiId}. Previous KPI moved to Chart Library.`;
            }
        }


        function insertCustomKpiFromPopup() {
            if (!currentData || !customPopupKpi) return;
            if (!Array.isArray(currentData.kpis)) currentData.kpis = [];

            const nextKpi = cloneKpi(customPopupKpi);
            delete nextKpi._id;
            ensureKpiId(nextKpi);
            currentData.kpis.push(nextKpi);

            renderKpisSection(currentData, getThemeColor());
            renderChartLibrary();

            const status = document.getElementById('chart-request-status');
            if (status) status.textContent = `Inserted KPI "${nextKpi.label || 'Custom KPI'}" on dashboard.`;
            closeCustomKpiPopup();
        }

        function populateKpiReplaceOptions() {
            const sel = document.getElementById('custom-kpi-replace-select');
            if (!sel) return;
            sel.innerHTML = '';
            const kpis = Array.isArray(currentData?.kpis) ? currentData.kpis : [];
            kpis.forEach((k, idx) => {
                const id = ensureKpiId(k);
                const option = document.createElement('option');
                option.value = id;
                option.textContent = `${idx + 1}. ${k.label || 'KPI'}`;
                sel.appendChild(option);
            });
        }

        function enableCustomKpiReplaceMode() {
            if (!customPopupKpi) return;
            pendingKpiReplaceLibraryId = customPopupKpiSourceLibraryId || '__custom_kpi_popup__';
            const row = document.getElementById('custom-kpi-replace-row');
            if (row) {
                populateKpiReplaceOptions();
                row.style.display = 'flex';
            }
            refreshKpiReplaceTargets();
            const status = document.getElementById('chart-request-status');
            if (status) status.textContent = 'Select a KPI card and click Replace Selected.';
        }

        function applyCustomKpiReplaceSelection() {
            const sel = document.getElementById('custom-kpi-replace-select');
            const targetId = sel ? String(sel.value || '').trim() : '';
            if (!targetId) return;
            applyLibraryKpiToSlot(targetId);
        }

        async function _postCustomArtifactRequest(promptText, artifactType = 'chart', clarificationChoice = null) {
            const formData = new FormData();
            formData.append('prompt', String(promptText || ''));
            formData.append('artifact_type', artifactType);
            if (currentData && currentData.session_id) {
                formData.append('session_id', currentData.session_id);
            }
            if (clarificationChoice) {
                formData.append('clarification_choice', JSON.stringify(clarificationChoice));
            }

            const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
            const res = await fetch('/api/custom-chart/', {
                method: 'POST',
                body: formData,
                headers: { 'X-CSRFToken': csrfToken }
            });

            const data = await res.json();
            if (!res.ok) {
                throw new Error(data.error || 'Failed to generate artifact');
            }
            return data;
        }

        function _buildClarificationPromptText(clarification) {
            const keyword = String((clarification && clarification.keyword) || '').trim();
            const question = String((clarification && clarification.question) || '').trim() ||
                'Your request matches multiple columns. Please choose one.';
            const options = Array.isArray(clarification && clarification.options)
                ? clarification.options
                : [];

            const lines = [question];
            if (keyword) {
                lines.push(`Keyword: ${keyword}`);
            }
            lines.push('');
            options.forEach((opt, idx) => {
                const label = String((opt && (opt.label || opt.column)) || `Option ${idx + 1}`);
                lines.push(`${idx + 1}. ${label}`);
            });
            lines.push('');
            lines.push('Enter the option number.');
            return lines.join('\n');
        }

        function _askUserForClarificationChoice(clarification, statusEl) {
            const options = Array.isArray(clarification && clarification.options)
                ? clarification.options
                : [];
            if (!options.length) {
                throw new Error('Clarification options are missing. Please mention the column explicitly in your request.');
            }

            const message = _buildClarificationPromptText(clarification);
            for (let attempt = 0; attempt < 3; attempt++) {
                const raw = window.prompt(message, '1');
                if (raw === null) {
                    if (statusEl) statusEl.textContent = 'Chart request cancelled.';
                    return null;
                }

                const idx = Number.parseInt(String(raw).trim(), 10) - 1;
                if (!Number.isInteger(idx) || idx < 0 || idx >= options.length) {
                    alert('Please enter a valid option number from the list.');
                    continue;
                }

                const selected = options[idx] || {};
                const column = String(selected.column || selected.label || '').trim();
                const keyword = String((clarification && clarification.keyword) || '').trim();
                if (!column) {
                    alert('Selected option is invalid. Please try again.');
                    continue;
                }

                return { keyword, column };
            }

            if (statusEl) statusEl.textContent = 'Could not resolve clarification. Please retry with explicit column name.';
            return null;
        }

        async function requestChartWithClarification(promptText, statusEl) {
            let clarificationChoice = null;
            let mergedLogs = [];

            for (let round = 0; round < 3; round++) {
                const data = await _postCustomArtifactRequest(promptText, 'chart', clarificationChoice);
                if (Array.isArray(data.logs)) {
                    mergedLogs = mergedLogs.concat(data.logs);
                }

                if (!data.needs_clarification) {
                    data.logs = mergedLogs;
                    return data;
                }

                const clarification = data.clarification || {};
                if (statusEl) {
                    statusEl.textContent = 'Clarification needed. Please choose the correct column.';
                }

                const choice = _askUserForClarificationChoice(clarification, statusEl);
                if (!choice) {
                    return null;
                }

                clarificationChoice = choice;
                if (statusEl) {
                    statusEl.textContent = `Using '${choice.column}' for '${choice.keyword || 'term'}'. Regenerating...`;
                }
            }

            throw new Error('Could not resolve ambiguity after multiple attempts. Please mention the exact column in your prompt.');
        }

        async function submitCustomChartRequest() {
            if (!currentData) {
                alert('Please start AI Dashboard first.');
                return;
            }

            const input = document.getElementById('chart-request-input');
            const button = document.getElementById('chart-request-btn');
            const status = document.getElementById('chart-request-status');
            const prompt = (input.value || '').trim();

            if (!prompt) {
                status.textContent = 'Enter a chart request.';
                return;
            }

            button.disabled = true;
            status.textContent = 'Generating...';

            try {
                const data = await requestChartWithClarification(prompt, status);
                if (!data) {
                    return;
                }

                const generatedChart = data.chart || null;
                if (!generatedChart) {
                    throw new Error('No chart returned by backend');
                }

                generatedChart.sql = data.generated_sql || generatedChart.sql || '';

                const libraryEntry = addChartToLibrary(generatedChart, {
                    source: 'Generated',
                    sql: data.generated_sql || ''
                });
                if (!libraryEntry) {
                    throw new Error('Unable to save generated chart');
                }

                if (Array.isArray(data.logs) && currentData) {
                    if (!Array.isArray(currentData.logs)) currentData.logs = [];
                    data.logs.forEach(logLine => {
                        currentData.logs.push(String(logLine || ''));
                    });
                }

                openLibraryChartInPopup(libraryEntry.id);
                status.textContent = 'Chart saved to library. Click Insert to add, or click Replace to choose a chart to replace. Open View Logs to inspect LLM payload logs.';
            } catch (error) {
                status.textContent = 'Request failed.';
                alert('Error: ' + error.message);
            } finally {
                button.disabled = false;
            }
        }

        async function requestKpiWithClarification(promptText, statusEl) {
            let clarificationChoice = null;
            let mergedLogs = [];

            for (let round = 0; round < 3; round++) {
                const data = await _postCustomArtifactRequest(promptText, 'kpi', clarificationChoice);
                if (Array.isArray(data.logs)) {
                    mergedLogs = mergedLogs.concat(data.logs);
                }

                if (!data.needs_clarification) {
                    data.logs = mergedLogs;
                    return data;
                }

                const clarification = data.clarification || {};
                if (statusEl) {
                    statusEl.textContent = 'KPI clarification needed. Please choose the correct column.';
                }

                const choice = _askUserForClarificationChoice(clarification, statusEl);
                if (!choice) return null;

                clarificationChoice = choice;
                if (statusEl) {
                    statusEl.textContent = `Using '${choice.column}' for KPI term '${choice.keyword || 'term'}'. Regenerating...`;
                }
            }

            throw new Error('Could not resolve KPI ambiguity after multiple attempts. Please mention the exact column name.');
        }

        async function submitCustomKpiRequest() {
            if (!currentData) {
                alert('Please start AI Dashboard first.');
                return;
            }

            const input = document.getElementById('chart-request-input');
            const button = document.getElementById('chart-request-btn');
            const status = document.getElementById('chart-request-status');
            const prompt = (input.value || '').trim();

            if (!prompt) {
                status.textContent = 'Enter a KPI request.';
                return;
            }

            button.disabled = true;
            status.textContent = 'Generating KPI...';

            try {
                const data = await requestKpiWithClarification(prompt, status);
                if (!data) {
                    return;
                }

                const generatedKpi = data.kpi || null;
                if (!generatedKpi) {
                    throw new Error('No KPI returned by backend');
                }

                const nextKpi = cloneKpi(generatedKpi);
                ensureKpiId(nextKpi);
                if (data.generated_sql && typeof data.generated_sql === 'object') {
                    nextKpi.sql = String(data.generated_sql.value_sql || nextKpi.sql || '');
                    nextKpi.trend_sql = String(data.generated_sql.trend_sql || nextKpi.trend_sql || '');
                }

                const libraryEntry = addKpiToLibrary(nextKpi, {
                    source: 'Generated',
                    sql: data.generated_sql || ''
                });

                if (Array.isArray(data.logs) && currentData) {
                    if (!Array.isArray(currentData.logs)) currentData.logs = [];
                    data.logs.forEach(logLine => {
                        currentData.logs.push(String(logLine || ''));
                    });
                }

                if (libraryEntry) {
                    openCustomKpiPopup(libraryEntry);
                }
                const statusEl = document.getElementById('chart-request-status');
                if (statusEl) {
                    statusEl.textContent = `KPI saved to library. Click Insert to add, or click Replace to choose which KPI to replace.`;
                }
            } catch (error) {
                status.textContent = 'KPI request failed.';
                alert('Error: ' + error.message);
            } finally {
                button.disabled = false;
            }
        }

        function openCustomChartPopup(sqlText) {
            if (!customPopupChart) return;

            const popup = document.getElementById('custom-chart-popup');
            const title = document.getElementById('custom-chart-title');
            const plotContainer = document.getElementById('custom-chart-plot');
            const sqlEl = document.getElementById('custom-chart-sql');
            const copyBtn = document.getElementById('copy-custom-sql-btn');
            const color = getThemeColor();

            title.textContent = customPopupChart.title || 'Custom Chart';
            sqlEl.textContent = sqlText ? `SQL: ${sqlText}` : 'SQL: Not available';
            copyBtn.disabled = !sqlText;
            copyBtn.textContent = 'Copy SQL';

            const replaceRow = document.getElementById('custom-chart-replace-row');
            if (replaceRow) replaceRow.style.display = 'none';
            popup.style.display = 'flex';
            popup.style.left = `${Math.max(12, window.innerWidth - 660)}px`;
            popup.style.top = `${Math.max(12, window.innerHeight - 500)}px`;

            plotContainer.innerHTML = '';
            const innerPlot = document.createElement('div');
            innerPlot.style.width = '100%';
            innerPlot.style.height = '100%';
            plotContainer.appendChild(innerPlot);

            setTimeout(() => {
                renderSingleChart(innerPlot, customPopupChart, color, true);
            }, 50);
        }
        function insertCustomChartFromPopup() {
            if (!currentData || !customPopupChart) return;
            if (!Array.isArray(currentData.charts)) currentData.charts = [];

            const nextChart = cloneChart(customPopupChart);
            insertChartWithoutGlobalRelayout(nextChart);
            renderChartLibrary();

            const status = document.getElementById('chart-request-status');
            if (status) status.textContent = `Inserted "${nextChart.title || 'Custom Chart'}" on dashboard.`;
            closeCustomChartPopup();
        }

        function populateChartReplaceOptions() {
            const sel = document.getElementById('custom-chart-replace-select');
            if (!sel) return;
            sel.innerHTML = '';
            const charts = Array.isArray(currentData?.charts) ? currentData.charts : [];
            charts.forEach((c, idx) => {
                if (!c) return;
                const id = c.id || `chart_${idx}`;
                const option = document.createElement('option');
                option.value = id;
                const title = c._removed ? 'Empty Slot' : (c.title || 'Chart');
                option.textContent = `${id} - ${title}`;
                sel.appendChild(option);
            });
        }

        function enableCustomChartReplaceMode() {
            if (!customPopupChart) return;
            const row = document.getElementById('custom-chart-replace-row');
            if (!row) return;
            populateChartReplaceOptions();
            row.style.display = 'flex';
            const status = document.getElementById('chart-request-status');
            if (status) status.textContent = 'Select a chart and click Replace Selected.';
        }

        function applyCustomChartReplaceSelection() {
            const sel = document.getElementById('custom-chart-replace-select');
            const targetId = sel ? String(sel.value || '').trim() : '';
            if (!targetId) return;
            applyCustomChartToSlot(targetId);
        }

        async function copyCustomChartSql() {
            const sqlEl = document.getElementById('custom-chart-sql');
            const copyBtn = document.getElementById('copy-custom-sql-btn');
            const status = document.getElementById('chart-request-status');
            const sql = (sqlEl.textContent || '').replace(/^SQL:\s*/i, '').trim();

            if (!sql || sql.toLowerCase() === 'not available') return;

            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(sql);
                } else {
                    const ta = document.createElement('textarea');
                    ta.value = sql;
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                }

                copyBtn.textContent = 'Copied';
                status.textContent = 'SQL copied to clipboard.';
                setTimeout(() => {
                    copyBtn.textContent = 'Copy SQL';
                }, 1200);
            } catch (err) {
                status.textContent = 'Could not copy SQL.';
            }
        }

        function closeCustomChartPopup() {
            const popup = document.getElementById('custom-chart-popup');
            popup.style.display = 'none';
            customPopupChart = null;
            customPopupSourceLibraryId = null;
            const replaceRow = document.getElementById('custom-chart-replace-row');
            if (replaceRow) replaceRow.style.display = 'none';
            highlightDropTarget(null);
        }

        function openCustomKpiPopup(entry) {
            if (!entry || entry.artifact !== 'kpi' || !entry.kpi) return;

            const popup = document.getElementById('custom-kpi-popup');
            const body = document.getElementById('custom-kpi-body');
            const title = document.getElementById('custom-kpi-title');
            const color = getThemeColor();

            customPopupKpiSourceLibraryId = entry.id || null;
            customPopupKpi = cloneKpi(entry.kpi);
            const trendData = Array.isArray(customPopupKpi.sparkline) ? customPopupKpi.sparkline : [];
            const trendChange = calculateTrend(trendData);
            const isPositive = trendChange >= 0;
            const trendWindowLabel = getKpiTrendWindowLabel(trendData);
            const trendColor = '#8b5cf6';
            const sparkId = `custom-kpi-spark-${Date.now()}`;

            body.innerHTML = `
                <div class="kpi-card" style="border-left-color:${color}; min-height: 120px; min-width: 260px; transform:none;">
                    <div class="kpi-card-content">
<div class="text-[10px] uppercase text-slate-300 font-bold tracking-wider">${escapeHtml(customPopupKpi.label || 'KPI')}</div>
                        <div class="text-[1.65rem] leading-none font-extrabold text-white mt-1 mb-1">${escapeHtml(customPopupKpi.value || '0')}</div>
                        <div class="trend-badge ${isPositive ? 'trend-up' : 'trend-down'}">
                            ${formatKpiTrendBadge(trendChange, trendWindowLabel)}
                        </div>
                    </div>
                    <div class="sparkline-container" id="${sparkId}"></div>
                </div>
            `;

            if (title) title.textContent = customPopupKpi.label || 'KPI';
            const replaceRow = document.getElementById('custom-kpi-replace-row');
            if (replaceRow) replaceRow.style.display = 'none';
            popup.style.display = 'flex';
            popup.style.left = `${Math.max(12, window.innerWidth - 380)}px`;
            popup.style.top = `${Math.max(12, window.innerHeight - 300)}px`;

            refreshKpiReplaceTargets();
            setTimeout(() => {
                const data = trendData.length ? trendData : [0, 0, 0, 0, 0, 0];
                createSparkline(sparkId, data, trendColor);
            }, 40);
        }

        function closeCustomKpiPopup() {
            const popup = document.getElementById('custom-kpi-popup');
            if (popup) {
                popup.style.display = 'none';
                popup.classList.remove('dragging');
            }
            customPopupKpi = null;
            customPopupKpiSourceLibraryId = null;
            const replaceRow = document.getElementById('custom-kpi-replace-row');
            if (replaceRow) replaceRow.style.display = 'none';
            customKpiPopupDragging = false;
            pendingKpiReplaceLibraryId = null;
            highlightKpiDropTarget(null);
            refreshKpiReplaceTargets();

            document.removeEventListener('mousemove', onCustomKpiPopupMouseMove);
            document.removeEventListener('mouseup', onCustomKpiPopupMouseUp);
        }

        function getDropTargetKpiId(clientX, clientY) {
            const cards = document.querySelectorAll('#kpi-container .kpi-card');
            for (const card of cards) {
                const rect = card.getBoundingClientRect();
                if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
                    return card.id;
                }
            }
            return null;
        }

        function highlightKpiDropTarget(targetId) {
            document.querySelectorAll('#kpi-container .kpi-card').forEach(card => {
                if (targetId && card.id === targetId) card.classList.add('kpi-drop-target');
                else card.classList.remove('kpi-drop-target');
            });
        }

        function onCustomKpiPopupMouseMove(e) {
            if (!customKpiPopupDragging) return;

            const popup = document.getElementById('custom-kpi-popup');
            const width = popup.offsetWidth;
            const height = popup.offsetHeight;
            const maxLeft = Math.max(6, window.innerWidth - width - 6);
            const maxTop = Math.max(6, window.innerHeight - height - 6);

            const nextLeft = Math.min(Math.max(6, e.clientX - customKpiPopupOffset.x), maxLeft);
            const nextTop = Math.min(Math.max(6, e.clientY - customKpiPopupOffset.y), maxTop);

            popup.style.left = `${nextLeft}px`;
            popup.style.top = `${nextTop}px`;

            const target = getDropTargetKpiId(e.clientX, e.clientY);
            highlightKpiDropTarget(target);
        }

        function onCustomKpiPopupMouseUp(e) {
            if (!customKpiPopupDragging) return;

            customKpiPopupDragging = false;
            const popup = document.getElementById('custom-kpi-popup');
            popup.classList.remove('dragging');

            const target = getDropTargetKpiId(e.clientX, e.clientY);
            highlightKpiDropTarget(null);

            document.removeEventListener('mousemove', onCustomKpiPopupMouseMove);
            document.removeEventListener('mouseup', onCustomKpiPopupMouseUp);

            if (target) {
                applyLibraryKpiToSlot(target);
            }
        }

        function initCustomKpiPopupDrag() {
            const header = document.getElementById('custom-kpi-header');
            if (!header || header.dataset.bound === '1') return;

            header.dataset.bound = '1';
            header.addEventListener('mousedown', (e) => {
                if (e.target.closest('button')) return;

                const popup = document.getElementById('custom-kpi-popup');
                if (!popup || popup.style.display === 'none') return;

                const rect = popup.getBoundingClientRect();
                customKpiPopupDragging = true;
                customKpiPopupOffset.x = e.clientX - rect.left;
                customKpiPopupOffset.y = e.clientY - rect.top;
                popup.classList.add('dragging');

                document.addEventListener('mousemove', onCustomKpiPopupMouseMove);
                document.addEventListener('mouseup', onCustomKpiPopupMouseUp);
            });
        }

        function getDropTargetChartId(clientX, clientY) {
            for (const id of chartSlotIds) {
                const el = document.getElementById(id);
                if (!el) continue;
                const rect = el.getBoundingClientRect();
                if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
                    return id;
                }
            }
            return null;
        }

        function highlightDropTarget(targetId) {
            chartSlotIds.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                if (id === targetId) el.classList.add('drop-target');
                else el.classList.remove('drop-target');
            });
        }
        function applyCustomChartToSlot(slotId) {
            if (!currentData || !currentData.charts || !customPopupChart) return;

            const targetIndex = currentData.charts.findIndex(c => c.id === slotId);
            if (targetIndex === -1) return;

            const replaced = cloneChart(currentData.charts[targetIndex]);
            if (replaced && hasRenderableChartData(replaced)) {
                addChartToLibrary(replaced, { source: `Replaced ${slotId}` });
            }

            const replacement = cloneChart(customPopupChart);
            replacement.id = slotId;
            replacement._layoutSpan = replaced && Number(replaced._layoutSpan) > 0 ? Number(replaced._layoutSpan) : (Number(replacement._layoutSpan) || 1);
            replacement._layoutMinH = replaced && Number(replaced._layoutMinH) > 0 ? Number(replaced._layoutMinH) : (Number(replacement._layoutMinH) || 120);
            replacement.original = createChartSnapshot(replacement);

            currentData.charts[targetIndex] = replacement;
            renderChartById(slotId);
            renderChartLibrary();
            closeCustomChartPopup();

            const status = document.getElementById('chart-request-status');
            status.textContent = `Replaced ${slotId}. Previous chart moved to Chart Library.`;
        }

        function onCustomPopupMouseMove(e) {
            if (!customPopupDragging) return;

            const popup = document.getElementById('custom-chart-popup');
            const width = popup.offsetWidth;
            const height = popup.offsetHeight;
            const maxLeft = Math.max(6, window.innerWidth - width - 6);
            const maxTop = Math.max(6, window.innerHeight - height - 6);

            const nextLeft = Math.min(Math.max(6, e.clientX - customPopupOffset.x), maxLeft);
            const nextTop = Math.min(Math.max(6, e.clientY - customPopupOffset.y), maxTop);

            popup.style.left = `${nextLeft}px`;
            popup.style.top = `${nextTop}px`;

            const target = getDropTargetChartId(e.clientX, e.clientY);
            highlightDropTarget(target);
        }

        function onCustomPopupMouseUp(e) {
            if (!customPopupDragging) return;

            customPopupDragging = false;
            const popup = document.getElementById('custom-chart-popup');
            popup.classList.remove('dragging');

            const target = getDropTargetChartId(e.clientX, e.clientY);
            highlightDropTarget(null);

            document.removeEventListener('mousemove', onCustomPopupMouseMove);
            document.removeEventListener('mouseup', onCustomPopupMouseUp);

            if (target) {
                applyCustomChartToSlot(target);
            }
        }

        function initCustomPopupDrag() {
            const header = document.getElementById('custom-chart-header');
            if (!header || header.dataset.bound === '1') return;

            header.dataset.bound = '1';
            header.addEventListener('mousedown', (e) => {
                if (e.target.closest('button')) return;

                const popup = document.getElementById('custom-chart-popup');
                if (popup.style.display === 'none') return;

                const rect = popup.getBoundingClientRect();
                customPopupDragging = true;
                customPopupOffset.x = e.clientX - rect.left;
                customPopupOffset.y = e.clientY - rect.top;
                popup.classList.add('dragging');

                document.addEventListener('mousemove', onCustomPopupMouseMove);
                document.addEventListener('mouseup', onCustomPopupMouseUp);
            });
        }

        initCustomPopupDrag();
        initCustomKpiPopupDrag();

        function createSparkline(containerId, data, color) {
            console.log(`createSparkline called for ${containerId}`, data, color);
            
            if (!data || data.length === 0) {
                console.warn(`No data for ${containerId}`);
                return;
            }
            
            const container = document.getElementById(containerId);
            if (!container) {
                console.error(`Container ${containerId} not found!`);
                return;
            }
            
            console.log(`Container ${containerId} found, dimensions:`, container.offsetWidth, 'x', container.offsetHeight);
            
            const trace = {
                y: data,
                x: data.map((_, i) => i),
                type: 'scatter',
                mode: 'lines',
                line: { 
                    color: color, 
                    width: 2,
                    shape: 'spline'
                },
                fill: 'tozeroy',
                fillcolor: color + '25',
                hovertemplate: '%{y:,.0f}<extra></extra>',
                showlegend: false
            };

            const layout = {
                margin: { t: 5, r: 5, b: 5, l: 5 },
                xaxis: { 
                    visible: false,
                    showgrid: false,
                    zeroline: false,
                    fixedrange: true
                },
                yaxis: { 
                    visible: false,
                    showgrid: false,
                    zeroline: false,
                    fixedrange: true
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                showlegend: false,
                height: 60,
                autosize: false,
                width: 120
            };

            const config = {
                responsive: false, 
                displayModeBar: false,
                staticPlot: false
            };

            try {
                Plotly.newPlot(containerId, [trace], layout, config).then(() => {
                    console.log(`Sparkline ${containerId} created successfully`);
                });
            } catch (error) {
                console.error(`Error creating sparkline ${containerId}:`, error);
            }
        }

        function calculateTrend(data) {
            if (!Array.isArray(data)) return 0;
            const clean = data
                .map(v => Number(v))
                .filter(v => Number.isFinite(v));

            if (clean.length < 2) return 0;

            const avg = arr => arr.reduce((a, b) => a + b, 0) / arr.length;
            const w = clean.length >= 6 ? 3 : 1;

            // Use beginning vs ending window so trend reflects full sparkline direction.
            const prev = avg(clean.slice(0, w));
            const curr = avg(clean.slice(-w));

            if (!Number.isFinite(prev) || !Number.isFinite(curr)) return 0;

            if (Math.abs(prev) < 1e-9) {
                if (Math.abs(curr) < 1e-9) return 0;
                return curr > 0 ? 100 : -100;
            }

            let change = ((curr - prev) / Math.abs(prev)) * 100;
            if (!Number.isFinite(change)) return 0;

            if (change > 999) change = 999;
            if (change < -999) change = -999;
            return change;
        }

        function expandChart(chartId) {
            const modal = document.getElementById('chart-modal');
            const modalContainer = document.getElementById('modal-chart-container');
            const modalTitle = document.getElementById('modal-title');
            
            const chart = currentData.charts.find(c => c.id === chartId);
            if (!chart) return;
            
            modalTitle.textContent = chart.title;
            modalContainer.innerHTML = '';
            
            const chartDiv = document.createElement('div');
            chartDiv.style.width = '100%';
            chartDiv.style.height = '100%';
            modalContainer.appendChild(chartDiv);
            
            const color = getThemeColor();
            
            modal.style.display = 'flex';
            
            // Delay rendering to ensure proper container sizing
            setTimeout(() => {
                renderSingleChart(chartDiv, chart, color, true);
            }, 150);
        }

        function closeModal(event) {
            if (event && event.target !== document.getElementById('chart-modal')) return;
            document.getElementById('chart-modal').style.display = 'none';
        }

        function toggleLogs() {
            document.getElementById('logs-modal').style.display = 'flex';
            renderLogs();
        }

        function closeLogs(event) {
            if (event && event.target !== document.getElementById('logs-modal')) return;
            document.getElementById('logs-modal').style.display = 'none';
        }

        function renderLogs() {
            if (!currentData || !currentData.logs) return;

            const logsContainer = document.getElementById('logs-content');
            logsContainer.innerHTML = '';

            const llmLines = (Array.isArray(currentData.logs) ? currentData.logs : []).filter(line => {
                const s = String(line || '');
                return s.includes('[LLM REQUEST]') || s.includes('[LLM RESPONSE]') || s.includes('[LLM ERROR]');
            });

            llmLines.forEach(log => {
                const line = String(log || '');
                const logDiv = document.createElement('div');
                logDiv.className = 'p-2 rounded';

                // Color code based on log type
                if (line.includes('SUCCESS') || line.includes('completed') || line.includes('[LLM RESPONSE]')) {
                    logDiv.className += ' bg-green-900/20 text-green-400';
                } else if (line.includes('ERROR') || line.includes('Error') || line.includes('Exception') || line.includes('FAILED')) {
                    logDiv.className += ' bg-red-900/20 text-red-400';
                } else if (line.includes('[LLM REQUEST]') || line.includes('[CHATBOT]') || line.includes('REQUEST')) {
                    logDiv.className += ' bg-violet-900/20 text-violet-400';
                } else if (line.includes('+-') || line.includes('->')) {
                    logDiv.className += ' bg-slate-800/50 text-slate-400 ml-4';
                } else {
                    logDiv.className += ' bg-slate-800/30 text-slate-300';
                }

                logDiv.textContent = line;
                logDiv.style.whiteSpace = 'pre-wrap';
                logDiv.style.wordBreak = 'break-word';
                logsContainer.appendChild(logDiv);
            });

            // Add master table preview
            if (currentData.master_preview && currentData.master_preview.columns) {
                const previewSection = document.createElement('div');
                previewSection.className = 'mt-6 p-4 bg-slate-800/50 rounded-lg';

                const previewTitle = document.createElement('div');
                previewTitle.className = 'text-sm font-bold text-violet-400 mb-3';
                previewTitle.textContent = 'Master Table Preview (First 3 Rows)';
                previewSection.appendChild(previewTitle);

                const table = document.createElement('table');
                table.className = 'w-full text-xs border-collapse';
                table.style.borderSpacing = '0';

                // Header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                currentData.master_preview.columns.forEach(col => {
                    const th = document.createElement('th');
                    th.className = 'bg-slate-700/50 text-slate-300 p-2 text-left border border-slate-600';
                    th.textContent = col;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Body
                const tbody = document.createElement('tbody');
                currentData.master_preview.rows.forEach((row, idx) => {
                    const tr = document.createElement('tr');
                    tr.className = idx % 2 === 0 ? 'bg-slate-800/30' : 'bg-slate-800/50';
                    row.forEach(cell => {
                        const td = document.createElement('td');
                        td.className = 'p-2 text-slate-300 border border-slate-600';
                        td.textContent = cell !== null && cell !== undefined ? String(cell) : 'NULL';
                        tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                });
                table.appendChild(tbody);

                previewSection.appendChild(table);
                logsContainer.appendChild(previewSection);
            }
        }

        function renderSingleChart(container, chart, color, isModal = false) {
            const commonLayout = {
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#94a3b8', size: isModal ? 12 : 10, family: 'Outfit' },
                margin: isModal ? { t: 50, l: 70, r: 40, b: 100 } : { t: 28, l: 35, r: 8, b: 35 },
                autosize: true,
                dragmode: isModal ? 'pan' : false
            };

            const config = {
                responsive: true,
                displayModeBar: isModal,
                modeBarButtonsToRemove: isModal ? ['lasso2d', 'select2d'] : [],
                scrollZoom: isModal,
                displaylogo: false
            };

            let trace = { marker: { color: color } };
            const chartType = String(chart.type || 'bar').toLowerCase();
            const showDataLabels = Boolean(chart && chart.showDataLabels);
            const formatValueLabel = (v) => {
                const n = Number(v);
                if (!Number.isFinite(n)) return String(v ?? '');
                if (Math.abs(n) >= 1000000) return `${(n / 1000000).toFixed(1)}M`;
                if (Math.abs(n) >= 1000) return `${(n / 1000).toFixed(1)}K`;
                return Number.isInteger(n) ? String(n) : n.toFixed(2);
            };

            if (chartType === 'table') {
                trace = {
                    type: 'table',
                    header: {
                        values: (chart.columns || []).map(c => `<b>${c}</b>`),
                        align: 'left',
                        fill: { color: 'rgba(30,41,59,0.9)' },
                        font: { color: '#e2e8f0', size: isModal ? 12 : 10 }
                    },
                    cells: {
                        values: (chart.columns || []).map((_, idx) => (chart.rows || []).map(r => (Array.isArray(r) ? (r[idx] ?? '') : ''))),
                        align: 'left',
                        fill: { color: 'rgba(15,23,42,0.7)' },
                        font: { color: '#cbd5e1', size: isModal ? 11 : 9 }
                    }
                };
            } else if (chartType === 'treemap') {
                trace = {
                    type: 'treemap',
                    labels: chart.labels || chart.x || [],
                    parents: chart.parents || (chart.labels ? new Array(chart.labels.length).fill('') : []),
                    values: chart.values || chart.y || [],
                    branchvalues: 'total',
                    marker: { colorscale: [[0, '#0b1a10'], [0.6, '#15803d'], [1, '#86efac']] },
                    textinfo: showDataLabels ? 'label+value' : 'label'
                };
            } else if (chartType === 'waterfall') {
                trace = {
                    type: 'waterfall',
                    x: chart.x || [],
                    y: chart.y || [],
                    measure: chart.measure || new Array((chart.x || []).length).fill('relative'),
                    connector: { line: { color: '#64748b' } },
                    increasing: { marker: { color: '#22c55e' } },
                    decreasing: { marker: { color: '#ef4444' } },
                    totals: { marker: { color: color } }
                };
                if (showDataLabels) {
                    trace.text = (chart.y || []).map(v => formatValueLabel(v));
                    trace.textposition = 'outside';
                }
            } else if (chartType === 'pie') {
                trace.type = 'pie';
                trace.labels = chart.x;
                trace.values = chart.y;
                trace.hole = 0.6;
                trace.textinfo = showDataLabels ? 'percent+label+value' : 'percent+label';
                trace.textposition = 'inside';
                trace.marker = {
                    colors: [color, adjustColor(color,-20), adjustColor(color,-40), '#475569', '#334155'],
                    line: { color: '#0f172a', width: 2 }
                };
            } else if (chartType === 'heatmap') {
                trace.type = 'heatmap';
                trace.x = chart.x;
                trace.y = chart.y;
                trace.z = chart.z;
                trace.colorscale = [
                    [0, '#0b1a10'],
                    [0.35, '#14532d'],
                    [0.7, '#22c55e'],
                    [1, '#bbf7d0']
                ];
                trace.showscale = true;
                if (showDataLabels) {
                    trace.texttemplate = '%{z}';
                    trace.textfont = { color: '#e2e8f0', size: isModal ? 11 : 9 };
                }
            } else if (chartType === 'line') {
                trace.type = 'scatter';
                trace.mode = 'lines+markers';
                trace.x = chart.x;
                trace.y = chart.y;
                trace.line = { shape: 'spline', width: isModal ? 4 : 3, color: color };
                trace.fill = 'tozeroy';
                trace.fillcolor = color + '15';
                trace.marker = { size: isModal ? 8 : 6, color: color };
                if (showDataLabels) {
                    trace.mode = 'lines+markers+text';
                    trace.text = (chart.y || []).map(v => formatValueLabel(v));
                    trace.textposition = 'top center';
                }
            } else if (chartType === 'scatter') {
                trace.type = 'scatter';
                trace.mode = 'markers';
                trace.x = chart.x;
                trace.y = chart.y;
                trace.marker = {
                    size: isModal ? 10 : 7,
                    color: color,
                    opacity: 0.7,
                    line: { color: 'white', width: 1 }
                };
                if (showDataLabels) {
                    trace.mode = 'markers+text';
                    trace.text = (chart.y || []).map(v => formatValueLabel(v));
                    trace.textposition = 'top center';
                }
            } else {
                trace.type = 'bar';
                trace.x = chart.x;
                trace.y = chart.y;
                if (showDataLabels) {
                    trace.text = (chart.y || []).map(v => formatValueLabel(v));
                    trace.textposition = 'outside';
                    trace.cliponaxis = false;
                }
            }

            let xaxisConfig = {
                title: chart.xlabel,
                showgrid: false,
                tickfont: { size: isModal ? 11 : 8 },
                automargin: true
            };

            if (chartType === 'bar' && chart.x && chart.x.length > 10) {
                xaxisConfig.tickangle = -45;
                xaxisConfig.tickmode = 'linear';
                xaxisConfig.tick0 = 0;
                xaxisConfig.dtick = Math.ceil(chart.x.length / (isModal ? 15 : 8));
            } else if (chartType === 'line') {
                const rawX = Array.isArray(chart.x) ? chart.x.slice(0, 160) : [];
                const dateHintCount = rawX.reduce((count, v) => {
                    const s = String(v ?? '').trim().toLowerCase();
                    if (!s) return count;
                    if (/(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/.test(s)) return count + 1;
                    if (/[\-/:t]/.test(s)) return count + 1;
                    if (/^\d{6}$/.test(s)) {
                        const y = parseInt(s.slice(0, 4), 10);
                        const m = parseInt(s.slice(4, 6), 10);
                        if (y >= 1900 && y <= 2100 && m >= 1 && m <= 12) return count + 1;
                    }
                    if (/^\d{8}$/.test(s)) {
                        const y = parseInt(s.slice(0, 4), 10);
                        const m = parseInt(s.slice(4, 6), 10);
                        const d = parseInt(s.slice(6, 8), 10);
                        if (y >= 1900 && y <= 2100 && m >= 1 && m <= 12 && d >= 1 && d <= 31) return count + 1;
                    }
                    return count;
                }, 0);

                const lineHasDateAxis = rawX.length > 0 && dateHintCount >= Math.max(2, Math.floor(rawX.length * 0.3));
                if (lineHasDateAxis) {
                    xaxisConfig.tickangle = -45;
                    xaxisConfig.tickformat = '%b %Y';
                    xaxisConfig.nticks = isModal ? 12 : 6;
                } else {
                    xaxisConfig.type = 'category';
                    xaxisConfig.tickangle = (chart.x && chart.x.length > 8) ? -45 : 0;
                    if (chart.x && chart.x.length > 20) {
                        xaxisConfig.tickmode = 'linear';
                        xaxisConfig.tick0 = 0;
                        xaxisConfig.dtick = Math.ceil(chart.x.length / (isModal ? 16 : 8));
                    }
                }
            } else if (chartType === 'heatmap') {
                xaxisConfig.tickfont.size = isModal ? 10 : 7;
                xaxisConfig.tickangle = 0;
            } else {
                xaxisConfig.tickangle = (chart.x && chart.x.length > 5) ? -45 : 0;
            }

            let finalLayout = { ...commonLayout };
            if (chartType === 'pie' || chartType === 'treemap') {
                finalLayout = {
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    font: { color: '#94a3b8', size: isModal ? 12 : 10, family: 'Outfit' },
                    margin: isModal ? { t: 50, l: 40, r: 40, b: 40 } : { t: 35, l: 20, r: 20, b: 20 },
                    title: isModal ? { text: chart.title, font: { color: 'white', size: 18 } } : { text: chart.title, font: { color: 'white', size: 12 }, y: 0.98 },
                    showlegend: false,
                    autosize: true,
                    dragmode: isModal ? 'pan' : false
                };
            } else if (chartType === 'table') {
                finalLayout = {
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    font: { color: '#94a3b8', size: isModal ? 12 : 10, family: 'Outfit' },
                    margin: isModal ? { t: 50, l: 20, r: 20, b: 20 } : { t: 35, l: 8, r: 8, b: 8 },
                    title: isModal ? { text: chart.title, font: { color: 'white', size: 18 } } : { text: chart.title, font: { color: 'white', size: 12 }, y: 0.98 },
                    autosize: true
                };
            } else {
                finalLayout = {
                    ...commonLayout,
                    title: isModal ? { text: chart.title, font: { color: 'white', size: 18 } } : { text: chart.title, font: { color: 'white', size: 12 }, y: 0.98 },
                    xaxis: {
                        ...xaxisConfig,
                        title: isModal ? chart.xlabel : ''
                    },
                    yaxis: {
                        title: isModal ? chart.ylabel : '',
                        showgrid: true,
                        gridcolor: '#33415530',
                        tickfont: { size: isModal ? 12 : 8 },
                        automargin: true,
                        fixedrange: !isModal
                    },
                    autotypenumbers: 'strict'
                };
            }

            Plotly.newPlot(container, [trace], finalLayout, config);
        }

        function getChartById(chartId) {
            return currentData && Array.isArray(currentData.charts)
                ? currentData.charts.find(c => c.id === chartId)
                : null;
        }

        function hasRenderableChartData(chart) {
            if (!chart) return false;
            const hasXY = Array.isArray(chart.x) && chart.x.length > 0 && Array.isArray(chart.y) && chart.y.length > 0;
            const hasTree = Array.isArray(chart.labels) && chart.labels.length > 0 && Array.isArray(chart.values) && chart.values.length > 0;
            const hasTable = Array.isArray(chart.rows) && chart.rows.length > 0;
            const hasHeat = Array.isArray(chart.z) && chart.z.length > 0;
            return hasXY || hasTree || hasTable || hasHeat;
        }

        function createEmptyChartState(chartId, fallbackTitle = 'Chart') {
            return {
                id: chartId,
                title: '',
                type: 'bar',
                xlabel: '',
                ylabel: '',
                x: [],
                y: [],
                z: [],
                columns: [],
                rows: [],
                labels: [],
                parents: [],
                values: [],
                measure: [],
                original: null,
                showDataLabels: false,
                _removed: true,
            };
        }
        function removeChart(chartId) {
            if (!currentData || !Array.isArray(currentData.charts)) return;
            const idx = currentData.charts.findIndex(c => c.id === chartId);
            if (idx === -1) return;

            const existing = cloneChart(currentData.charts[idx]);
            if (existing && hasRenderableChartData(existing)) {
                addChartToLibrary(existing, { source: `Removed ${chartId}` });
            }

            currentData.charts[idx] = createEmptyChartState(chartId);
            renderChartById(chartId);
            renderChartLibrary();

            const status = document.getElementById('chart-request-status');
            if (status) {
                status.textContent = `${chartId} removed. Slot left blank.`;
            }
        }

        function removeKpi(kpiId) {
            if (!currentData || !Array.isArray(currentData.kpis)) return;
            const idx = currentData.kpis.findIndex(k => ensureKpiId(k) === kpiId);
            if (idx === -1) return;

            const removed = cloneKpi(currentData.kpis[idx]);
            if (removed && (removed.label || removed.value)) {
                addKpiToLibrary(removed, { source: `Removed ${kpiId}` });
            }

            currentData.kpis.splice(idx, 1);
            delete widgetLayouts[kpiId];
            if (pendingKpiReplaceLibraryId) pendingKpiReplaceLibraryId = null;

            renderKpisSection(currentData, getThemeColor());
            renderChartLibrary();

            const status = document.getElementById('chart-request-status');
            if (status) {
                status.textContent = `${kpiId} removed.`;
            }
        }

        function closeEditMenus(exceptChartId = null) {
            document.querySelectorAll('.edit-dropdown.open').forEach(menu => {
                if (exceptChartId && menu.id === `edit-dropdown-${exceptChartId}`) return;
                menu.classList.remove('open');
            });
            document.querySelectorAll('.chart-controls.open').forEach(box => {
                if (exceptChartId && box.id === `chart-controls-${exceptChartId}`) return;
                box.classList.remove('open');
            });
        }

        function getEditableChartTypes(chart) {
            const preferred = ['bar', 'line', 'scatter', 'pie', 'heatmap', 'table', 'treemap', 'waterfall'];
            const hasXY = Array.isArray(chart?.x) && chart.x.length > 0 && Array.isArray(chart?.y) && chart.y.length > 0;
            const hasTree = Array.isArray(chart?.labels) && chart.labels.length > 0 && Array.isArray(chart?.values) && chart.values.length > 0;
            const hasHeat = Array.isArray(chart?.x) && Array.isArray(chart?.y) && Array.isArray(chart?.z) && chart.x.length > 0 && chart.y.length > 0 && chart.z.length > 0;
            const hasTable = Array.isArray(chart?.columns) && chart.columns.length > 0 && Array.isArray(chart?.rows) && chart.rows.length > 0;
            const tableHasTwoCols = hasTable && Array.isArray(chart.rows[0]) && chart.rows[0].length >= 2;

            const allowed = new Set();
            if (hasXY || tableHasTwoCols || hasTree) {
                ['bar', 'line', 'scatter', 'pie'].forEach(t => allowed.add(t));
            }
            if (hasXY || tableHasTwoCols) {
                allowed.add('waterfall');
            }
            if (hasHeat) {
                allowed.add('heatmap');
            }
            if (hasXY || hasHeat || hasTree || hasTable) {
                allowed.add('table');
            }
            if (hasTree || hasXY || tableHasTwoCols) {
                allowed.add('treemap');
            }

            if (chart && chart.type) {
                allowed.add(String(chart.type).toLowerCase());
            }

            return preferred.filter(t => allowed.has(t));
        }

        function buildChartControlsHtml(chartId) {
            const chart = getChartById(chartId);
            if (!chart) return '';

            const currentType = String(chart.type || 'bar').toLowerCase();
            const typeOptions = getEditableChartTypes(chart)
                .map(t => `<option value="${t}" ${t === currentType ? 'selected' : ''}>${chartTypeLabel(t)}</option>`)
                .join('');
            const labelsToggleText = chart.showDataLabels ? 'Hide Data Labels' : 'Show Data Labels';

            return `
                <div class="chart-controls" id="chart-controls-${chartId}">
                    <div class="edit-menu">
                        <button class="control-btn edit-toggle" onclick="toggleEditMenu('${chartId}')" title="Edit Chart">Edit</button>
                        <div class="edit-dropdown" id="edit-dropdown-${chartId}">
                            <div class="edit-row">
                                <span class="edit-label">Type</span>
                                <select class="edit-select" onchange="onChartTypeSelect('${chartId}', this)">${typeOptions}</select>
                            </div>
                            <button class="edit-item" onclick="swapAxes('${chartId}')">Swap X/Y</button>
                            <button class="edit-item" onclick="renameAxisLabels('${chartId}')">Edit Axis Labels</button>
                            <button class="edit-item" onclick="aiEditChart('${chartId}')">Edit with AI</button>
                            <button class="edit-item" onclick="toggleDataLabels('${chartId}')">${labelsToggleText}</button>
                            <button class="edit-item" onclick="sortChart('${chartId}')">Sort by Y</button>
                            <button class="edit-item" onclick="resetChart('${chartId}')">Reset Chart</button>
                        </div>
                    </div>
                    <button class="control-btn reset-toggle" onclick="resetChart('${chartId}')" title="Reset Chart">Reset</button>
                </div>
            `;
        }

        function getChartShellHtml(chartId) {
            return `
                <button class="expand-btn" onclick="expandChart('${chartId}')">Expand</button>
                <button class="widget-remove-btn" onclick="removeChart('${chartId}')" title="Remove Chart">x</button>
                <div class="widget-drag-handle" onmousedown="startWidgetDrag(event, '${chartId}')">Move</div>
                ${buildChartControlsHtml(chartId)}
                <div class="chart-plot-area" id="plot-${chartId}"></div>
            `;
        }

        function renderChartById(chartId) {
            const chart = getChartById(chartId);
            const el = document.getElementById(chartId);
            if (!chart || !el) return;

            el.style.display = 'flex';
            if (chart && chart._removed) {
                el.classList.add('chart-empty-slot');
                el.innerHTML = '';
                return;
            }

            el.classList.remove('chart-empty-slot');
            const color = getThemeColor();
            el.innerHTML = getChartShellHtml(chartId);

            const plotEl = document.getElementById(`plot-${chartId}`);
            initWidgetInteractionsForElement(el, chartId, 'chart');

            if (!hasRenderableChartData(chart)) {
                if (plotEl) {
                    plotEl.innerHTML = `
                        <div class="absolute inset-0 flex flex-col items-center justify-center text-slate-600">
                            <span class="text-xs font-mono opacity-50">No Data Available</span>
                        </div>
                        <div class="absolute top-3 left-4 text-xs font-bold text-slate-400">${chart.title || 'Chart'}</div>
                    `;
                    plotEl.style.position = 'relative';
                }
                return;
            }

            if (plotEl) {
                renderSingleChart(plotEl, chart, color, false);
            }
        }

        function toggleEditMenu(chartId) {
            const menu = document.getElementById(`edit-dropdown-${chartId}`);
            const controls = document.getElementById(`chart-controls-${chartId}`);
            if (!menu || !controls) return;

            const willOpen = !menu.classList.contains('open');
            closeEditMenus(chartId);
            if (willOpen) {
                menu.classList.add('open');
                controls.classList.add('open');
            } else {
                menu.classList.remove('open');
                controls.classList.remove('open');
            }
        }

        function ensureXYDataForEditing(chart) {
            const hasXY = Array.isArray(chart.x) && chart.x.length > 0 && Array.isArray(chart.y) && chart.y.length > 0;
            if (hasXY) return true;

            const hasTree = Array.isArray(chart.labels) && chart.labels.length > 0 && Array.isArray(chart.values) && chart.values.length > 0;
            if (hasTree) {
                chart.x = [...chart.labels];
                chart.y = chart.values.map(v => {
                    const n = Number(v);
                    return Number.isFinite(n) ? n : 0;
                });
                chart.xlabel = chart.xlabel || 'Category';
                chart.ylabel = chart.ylabel || 'Value';
                return true;
            }

            const hasTable = Array.isArray(chart.columns) && chart.columns.length >= 2 && Array.isArray(chart.rows) && chart.rows.length > 0;
            if (hasTable) {
                chart.x = chart.rows.map(r => Array.isArray(r) ? String(r[0] ?? '') : '');
                chart.y = chart.rows.map(r => {
                    const n = Number(Array.isArray(r) ? r[1] : 0);
                    return Number.isFinite(n) ? n : 0;
                });
                chart.xlabel = chart.xlabel || String(chart.columns[0] || 'X');
                chart.ylabel = chart.ylabel || String(chart.columns[1] || 'Y');
                return true;
            }

            return false;
        }

        function ensureTableDataForEditing(chart) {
            const hasTable = Array.isArray(chart.columns) && chart.columns.length > 0 && Array.isArray(chart.rows) && chart.rows.length > 0;
            if (hasTable) return true;

            const hasHeat = Array.isArray(chart.x) && Array.isArray(chart.y) && Array.isArray(chart.z) && chart.x.length > 0 && chart.y.length > 0 && chart.z.length > 0;
            if (hasHeat) {
                const size = Math.min(chart.x.length, chart.y.length, chart.z.length);
                chart.columns = ['x', 'y', 'z'];
                chart.rows = Array.from({ length: size }, (_, i) => [chart.x[i], chart.y[i], chart.z[i]]);
                return true;
            }

            if (ensureXYDataForEditing(chart)) {
                const size = Math.min(chart.x.length, chart.y.length);
                chart.columns = [chart.xlabel || 'x', chart.ylabel || 'y'];
                chart.rows = Array.from({ length: size }, (_, i) => [chart.x[i], chart.y[i]]);
                return true;
            }

            return false;
        }

        function ensureTreemapDataForEditing(chart) {
            const hasTree = Array.isArray(chart.labels) && chart.labels.length > 0 && Array.isArray(chart.values) && chart.values.length > 0;
            if (hasTree) return true;

            if (ensureXYDataForEditing(chart)) {
                chart.labels = chart.x.map(v => String(v));
                chart.values = chart.y.map(v => {
                    const n = Number(v);
                    return Number.isFinite(n) ? n : 0;
                });
                chart.parents = new Array(chart.labels.length).fill('');
                return true;
            }
            return false;
        }

        function applyChartType(chart, newType) {
            const type = String(newType || '').toLowerCase();
            if (!type) return false;

            if (['bar', 'line', 'scatter', 'pie', 'waterfall'].includes(type)) {
                if (!ensureXYDataForEditing(chart)) {
                    alert('Chart cannot be converted to this type due to missing X/Y data.');
                    return false;
                }
                chart.type = type;
                return true;
            }

            if (type === 'heatmap') {
                const hasHeat = Array.isArray(chart.x) && Array.isArray(chart.y) && Array.isArray(chart.z) && chart.x.length && chart.y.length && chart.z.length;
                if (!hasHeat) {
                    alert('Heatmap needs x, y and z data.');
                    return false;
                }
                chart.type = type;
                return true;
            }

            if (type === 'table') {
                if (!ensureTableDataForEditing(chart)) {
                    alert('Table view could not be generated from this chart data.');
                    return false;
                }
                chart.type = type;
                return true;
            }

            if (type === 'treemap') {
                if (!ensureTreemapDataForEditing(chart)) {
                    alert('Treemap needs label/value-style data.');
                    return false;
                }
                chart.type = type;
                return true;
            }

            return false;
        }

        function onChartTypeSelect(chartId, selectEl) {
            changeChartType(chartId, selectEl ? selectEl.value : null);
        }

        function changeChartType(chartId, explicitType = null) {
            const chart = getChartById(chartId);
            if (!chart) return;

            if (explicitType) {
                if (!applyChartType(chart, explicitType)) return;
            } else {
                const typeMap = { 'bar': 'line', 'line': 'scatter', 'scatter': 'bar' };
                const nextType = typeMap[String(chart.type || 'bar').toLowerCase()] || 'bar';
                if (!applyChartType(chart, nextType)) return;
            }

            closeEditMenus();
            renderChartById(chartId);
        }

        function swapAxes(chartId) {
            const chart = getChartById(chartId);
            if (!chart) return;

            if (String(chart.type || '').toLowerCase() === 'heatmap') {
                const hasHeat = Array.isArray(chart.x) && Array.isArray(chart.y) && Array.isArray(chart.z) && chart.x.length && chart.y.length && chart.z.length;
                if (!hasHeat) {
                    alert('Heatmap has no swappable x/y data.');
                    return;
                }
                [chart.x, chart.y] = [chart.y, chart.x];
                [chart.xlabel, chart.ylabel] = [chart.ylabel, chart.xlabel];
                closeEditMenus();
                renderChartById(chartId);
                return;
            }

            if (!ensureXYDataForEditing(chart)) {
                alert('This chart has no X/Y data to swap.');
                return;
            }

            [chart.x, chart.y] = [chart.y, chart.x];
            [chart.xlabel, chart.ylabel] = [chart.ylabel, chart.xlabel];

            closeEditMenus();
            renderChartById(chartId);
        }

        function renameAxisLabels(chartId) {
            const chart = getChartById(chartId);
            if (!chart) return;

            const newX = prompt('Enter X-axis label:', chart.xlabel || 'X Axis');
            if (newX === null) return;
            const newY = prompt('Enter Y-axis label:', chart.ylabel || 'Y Axis');
            if (newY === null) return;

            chart.xlabel = String(newX).trim() || chart.xlabel || 'X Axis';
            chart.ylabel = String(newY).trim() || chart.ylabel || 'Y Axis';

            closeEditMenus();
            renderChartById(chartId);
        }


        function toggleDataLabels(chartId) {
            const chart = getChartById(chartId);
            if (!chart) return;

            chart.showDataLabels = !Boolean(chart.showDataLabels);
            closeEditMenus();
            renderChartById(chartId);
        }

        async function aiEditChart(chartId) {
            const chart = getChartById(chartId);
            if (!chart || !currentData) return;

            const instruction = prompt(
                'What change do you want? Example: Replace Product with Brand and keep sales by month.',
                `Replace ${chart.xlabel || 'current dimension'} with ...`
            );
            if (instruction === null) return;

            const trimmed = String(instruction).trim();
            if (!trimmed) return;

            closeEditMenus();
            const status = document.getElementById('chart-request-status');
            if (status) status.textContent = `Updating ${chartId} with AI...`;

            try {
                const contextLines = [
                    'You are editing an existing chart on a dashboard.',
                    `Current chart title: ${chart.title || 'Untitled'}`,
                    `Current chart type: ${chart.type || 'bar'}`,
                    `Current X label: ${chart.xlabel || 'X'}`,
                    `Current Y label: ${chart.ylabel || 'Y'}`,
                    'Keep the same business intent/metric where possible, and apply the user requested label/dimension change.',
                    `User change request: ${trimmed}`
                ];

                const aiPrompt = contextLines.join('\n');

                const data = await requestChartWithClarification(aiPrompt, status);
                if (!data) {
                    if (status) status.textContent = 'AI chart edit cancelled.';
                    return;
                }

                const generatedChart = data.chart || null;
                if (!generatedChart) {
                    throw new Error('No chart returned by backend');
                }

                const targetIndex = currentData.charts.findIndex(c => c.id === chartId);
                if (targetIndex === -1) {
                    throw new Error(`Target chart ${chartId} not found`);
                }

                const replaced = cloneChart(currentData.charts[targetIndex]);
                if (replaced) {
                    addChartToLibrary(replaced, { source: `AI Edit Replaced ${chartId}` });
                }

                const replacement = cloneChart(generatedChart);
                replacement.id = chartId;
                replacement._layoutSpan = replaced && Number(replaced._layoutSpan) > 0 ? Number(replaced._layoutSpan) : (Number(replacement._layoutSpan) || 1);
                replacement._layoutMinH = replaced && Number(replaced._layoutMinH) > 0 ? Number(replaced._layoutMinH) : (Number(replacement._layoutMinH) || 120);
                replacement.original = createChartSnapshot(replacement);
                currentData.charts[targetIndex] = replacement;

                if (Array.isArray(data.logs) && currentData) {
                    if (!Array.isArray(currentData.logs)) currentData.logs = [];
                    data.logs.forEach(logLine => {
                        currentData.logs.push(String(logLine || ''));
                    });
                }

                renderChartById(chartId);
                renderChartLibrary();

                if (status) status.textContent = `${chartId} updated with AI.`;
            } catch (error) {
                if (status) status.textContent = 'AI chart edit failed.';
                alert('Error: ' + error.message);
            }
        }

        function sortChart(chartId) {
            const chart = getChartById(chartId);
            if (!chart) return;

            if (!ensureXYDataForEditing(chart)) {
                alert('This chart has no sortable X/Y data.');
                return;
            }

            chart.sortDirection = chart.sortDirection === 'asc' ? 'desc' : 'asc';
            const combined = chart.x.map((x, i) => ({ x, y: Number(chart.y[i]) || 0 }));
            combined.sort((a, b) => chart.sortDirection === 'asc' ? (a.y - b.y) : (b.y - a.y));

            chart.x = combined.map(item => item.x);
            chart.y = combined.map(item => item.y);

            closeEditMenus();
            renderChartById(chartId);
        }

        function resetChart(chartId) {
            const chart = getChartById(chartId);
            if (!chart || !chart.original) return;

            chart.x = [...chart.original.x];
            chart.y = [...chart.original.y];
            chart.z = chart.original.z ? [...chart.original.z] : [];
            chart.type = chart.original.type;
            chart.xlabel = chart.original.xlabel;
            chart.ylabel = chart.original.ylabel;
            chart.title = chart.original.title;
            chart.showDataLabels = Boolean(chart.original.showDataLabels);
            delete chart.sortDirection;

            closeEditMenus();
            renderChartById(chartId);
        }

        document.addEventListener('click', function(e) {
            if (!e.target.closest('.edit-menu')) {
                closeEditMenus();
            }
        });

        function renderDashboard(data) {
            document.querySelectorAll('.glass-panel').forEach(el => el.style.opacity = '1');
            document.getElementById('upload-screen').classList.add('hidden');
            document.getElementById('dashboard-screen').classList.remove('hidden');
            document.getElementById('dashboard-screen').classList.remove('with-chatbot-dock');
            updateChatbotDockVisibility();

            const color = getThemeColor();
            

            // Title & Theme
            const sessionLabel = document.getElementById('session-source-label');
            if (sessionLabel) {
                sessionLabel.textContent = 'Live Databricks Session';
            }
            const titleText = document.getElementById('dashboard-title-text');
            if (titleText) {
                titleText.innerText = 'AI Dashboard';
            }

            // Date Range Filter
            const dateContainer = document.getElementById('date-filter-container');
            const dateSeparator = document.getElementById('date-separator');
            const startDate = document.getElementById('start-date');
            const endDate = document.getElementById('end-date');
            const dateColumnSelect = document.getElementById('date-column-select');
            const dateColumns = Array.isArray(data.date_columns) ? data.date_columns : [];

            if (data.has_date_column && dateColumns.length > 0) {
                if (dateContainer) dateContainer.style.display = 'flex';
                if (dateSeparator) dateSeparator.style.display = 'block';

                const selectedDateColumn = String(data.selected_date_column || activeFilters['_date_column'] || dateColumns[0]);
                if (dateColumnSelect) {
                    dateColumnSelect.innerHTML = '';
                    dateColumns.forEach(col => {
                        const option = document.createElement('option');
                        option.value = String(col);
                        option.textContent = String(col);
                        dateColumnSelect.appendChild(option);
                    });
                    dateColumnSelect.value = dateColumns.includes(selectedDateColumn) ? selectedDateColumn : String(dateColumns[0]);
                    dateColumnSelect.dataset.appliedValue = String(dateColumnSelect.value || '');
                }
                activeFilters['_date_column'] = dateColumnSelect ? String(dateColumnSelect.value || dateColumns[0]) : String(selectedDateColumn);

                const minDate = data.date_range && data.date_range.min ? String(data.date_range.min) : '';
                const maxDate = data.date_range && data.date_range.max ? String(data.date_range.max) : '';

                if (startDate && endDate) {
                    if (minDate && maxDate) {
                        startDate.min = minDate;
                        startDate.max = maxDate;
                        endDate.min = minDate;
                        endDate.max = maxDate;

                        const serverStart = data.applied_start_date ? String(data.applied_start_date) : '';
                        const serverEnd = data.applied_end_date ? String(data.applied_end_date) : '';
                        const nextStart = activeFilters['_start_date'] ? String(activeFilters['_start_date']) : (serverStart || minDate);
                        const nextEnd = activeFilters['_end_date'] ? String(activeFilters['_end_date']) : (serverEnd || maxDate);
                        startDate.value = nextStart;
                        endDate.value = nextEnd;
                        startDate.dataset.appliedValue = nextStart;
                        endDate.dataset.appliedValue = nextEnd;
                        activeFilters['_start_date'] = nextStart;
                        activeFilters['_end_date'] = nextEnd;
                    } else {
                        startDate.removeAttribute('min');
                        startDate.removeAttribute('max');
                        endDate.removeAttribute('min');
                        endDate.removeAttribute('max');
                        const serverStart = data.applied_start_date ? String(data.applied_start_date) : '';
                        const serverEnd = data.applied_end_date ? String(data.applied_end_date) : '';
                        const nextStart = activeFilters['_start_date'] ? String(activeFilters['_start_date']) : serverStart;
                        const nextEnd = activeFilters['_end_date'] ? String(activeFilters['_end_date']) : serverEnd;
                        startDate.value = nextStart;
                        endDate.value = nextEnd;
                        startDate.dataset.appliedValue = nextStart;
                        endDate.dataset.appliedValue = nextEnd;
                    }
                }
            } else {
                if (dateContainer) dateContainer.style.display = 'none';
                if (dateSeparator) dateSeparator.style.display = 'none';
                delete activeFilters['_date_column'];
                delete activeFilters['_start_date'];
                delete activeFilters['_end_date'];
            }

            // Filters
            refreshFilterDefinitions(data.filters || []);

            // KPIs with Sparklines
            renderKpisSection(data, color);

            // Charts
            if (!Array.isArray(data.charts)) data.charts = [];
            ensureChartSlots(Math.max(5, data.charts.length));

            chartSlotIds.forEach(id => {
                const slot = document.getElementById(id);
                if (slot) {
                    slot.style.display = 'none';
                    slot.style.transform = '';
                    slot.style.width = '';
                    slot.style.height = '';
                    slot.style.gridColumn = 'span 1';
                    slot.innerHTML = '';
                }
            });

            data.charts.forEach((c, i) => {
                if (i >= chartSlotIds.length) return;
                const id = chartSlotIds[i];
                const slot = document.getElementById(id);
                if (!slot) return;
                c.id = id;
                slot.style.display = 'flex';
                renderChartById(id);
            });

            applyAdaptiveInsertLayout(data, { preferStored: true });
            renderChartLibrary();
            updateDashboardSidebarLayout();
        }

        function renderKpisSection(data, color) {
            const kpiBox = document.getElementById('kpi-container');
            if (!kpiBox) return;
            kpiBox.innerHTML = '';

            if (!Array.isArray(data.kpis)) data.kpis = [];
            const kpiCols = Math.max(4, data.kpis.length || 0);
            kpiBox.style.gridTemplateColumns = `repeat(${kpiCols}, minmax(220px, 1fr))`;
            kpiBox.style.overflowX = data.kpis.length > 4 ? 'auto' : 'hidden';
            kpiBox.style.overflowY = 'hidden';
            data.kpis.forEach(k => ensureKpiId(k));

            data.kpis.forEach((k) => {
                const kpiId = ensureKpiId(k);
                const sparklineId = `sparkline_${kpiId}`;
                const trendData = k.sparkline || [];
                const trendChange = calculateTrend(trendData);
                const isPositive = trendChange >= 0;
                const trendWindowLabel = getKpiTrendWindowLabel(trendData);

                const kpiDiv = document.createElement('div');
                kpiDiv.className = `kpi-card ${pendingKpiReplaceLibraryId ? 'kpi-replace-target' : ''}`;
                kpiDiv.id = kpiId;
                kpiDiv.style.borderLeftColor = color;
                kpiDiv.setAttribute('onclick', `handleKpiCardClick('${kpiId}')`);

                kpiDiv.innerHTML = `
                    <button class="widget-remove-btn" onclick="event.stopPropagation(); removeKpi('${kpiId}')" title="Remove KPI">x</button>
                    <div class="widget-drag-handle" onmousedown="startWidgetDrag(event, '${kpiId}')">Move</div>
                    <div class="kpi-card-content">
<div class="text-[10px] uppercase text-slate-300 font-bold tracking-wider">${k.label}</div>
                        <div class="text-[1.65rem] leading-none font-extrabold text-white mt-1 mb-1">${k.value}</div>
                        <div class="trend-badge ${isPositive ? 'trend-up' : 'trend-down'}">
                            ${formatKpiTrendBadge(trendChange, trendWindowLabel)}
                        </div>
                    </div>
                    <div class="sparkline-container" id="${sparklineId}"></div>
                `;

                kpiBox.appendChild(kpiDiv);
                initWidgetInteractionsForElement(kpiDiv, kpiId, 'kpi');
            });

            setTimeout(() => {
                data.kpis.forEach((k) => {
                    const kpiId = ensureKpiId(k);
                    const sparklineId = `sparkline_${kpiId}`;
                    const trendData = k.sparkline || [];

                    const container = document.getElementById(sparklineId);
                    if (!container) return;
                    if (trendData.length === 0) return;

                    createSparkline(sparklineId, trendData, '#8b5cf6');
                });
            }, 180);

            refreshKpiReplaceTargets();
        }

        function adjustColor(color, amount) {
            return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
        }

        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeModal();
                closeLogs();
            }
        });
        window.addEventListener('resize', updateDashboardSidebarLayout);
    </script>
</body>



</html>














































